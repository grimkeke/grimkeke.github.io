<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Stream读书笔记</title>
  <meta name="description" content="什么是流 流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询 的语句，而不是亲自实现一个查询功能）。对比之前面向集合，亲自来实现集合操作，通过流， 开发者可以关注与实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询Dish列表 中卡路里小于400的菜品名...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://0.0.0.0:4000/java8/2018/01/14/know-stream-api.html">
  <link rel="alternate" type="application/rss+xml" title="小笔记" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">小笔记</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于</a>
          
        
          
        
          
          <a class="page-link" href="/links/">常用链接</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Stream读书笔记</h1>
    <p class="post-meta"><time datetime="2018-01-14T11:57:44+08:00" itemprop="datePublished">Jan 14, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="什么是流">什么是流</h2>
<p>流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询
的语句，而不是亲自实现一个查询功能）。对比之前面向集合，亲自来实现集合操作，通过流，
开发者可以关注与实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询Dish列表
中卡路里小于400的菜品名称，并且根据菜品卡路里排序。java7的方法即为根据语义进行实现，
即首先遍历所有的菜品，找出小于400卡路里的菜品添加到临时列表，进行排序，然后再创建一个
列表用于提取菜品的名称。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public List&lt;String&gt; getLowCaloricDishesNamesInJava7(List&lt;Dish&gt; dishes){
    List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();
    for(Dish d: dishes){
        if(d.getCalories() &lt; 400){
            lowCaloricDishes.add(d);
        }
    }

    Collections.sort(lowCaloricDishes, new Comparator&lt;Dish&gt;() {
        public int compare(Dish d1, Dish d2){
            return Integer.compare(d1.getCalories(), d2.getCalories());
        }
    });

    List&lt;String&gt; lowCaloricDishesName = new ArrayList&lt;&gt;();
    for(Dish d: lowCaloricDishes){
        lowCaloricDishesName.add(d.getName());
    }
    return lowCaloricDishesName;
}
</code></pre>
</div>
<p>而java8的流操作就很直观，通过<code class="highlighter-rouge">.stream()</code>方法，将菜品列表
转换为菜品流，接着通过<code class="highlighter-rouge">filter</code>过滤，通过<code class="highlighter-rouge">sorted</code>进行排序，通过<code class="highlighter-rouge">map</code>将菜品列表映射
为名称列表，最后通过<code class="highlighter-rouge">collect</code>收集保存为List。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public List&lt;String&gt; getLowCaloricDishesNamesInJava8(List&lt;Dish&gt; dishes){
    return dishes.stream()
            .filter(d -&gt; d.getCalories() &lt; 400)
            .sorted(Comparator.comparing(Dish::getCalories))
            .map(Dish::getName)
            .collect(Collectors.toList());
}
</code></pre>
</div>
<p>而将流操作转变为并行操作也非常简单，只需将<code class="highlighter-rouge">.stream()</code>方法修改为<code class="highlighter-rouge">.parallelStream()</code>
方法即可。流默认会根据当前运行机器的内核数来进行并行执行。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public List&lt;String&gt; getLowCaloricDishesNamesInJava8(List&lt;Dish&gt; dishes){
    return dishes.parallelStream()
            .filter(d -&gt; d.getCalories() &lt; 400)
            .sorted(Comparator.comparing(Dish::getCalories))
            .map(Dish::getName)
            .collect(Collectors.toList());
}
</code></pre>
</div>
<p>除了生命式的表述数据操作方式之外，流的编写模式是链式的，即通过一系列方法组合成操作
流水线。而在流的内部，每个处理节点的操作也像流水线一样并行处理。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>           lamdba             lambda             lambda
             +                   +                  +
             |                   |                  |
menu    +----v-----+       +-----v----+       +-----v----+      +---------+
+-------&gt;  filter  +-------&gt;  sorted  +-------&gt;   map    +------&gt; collect |
        +----------+       +----------+       +----------+      +---------+
</code></pre>
</div>
<p>即流有如下三个特点：声明式、可复合（链式）、可并行。</p>
<h2 id="流与集合的理解">流与集合的理解</h2>
<p>集合可以理解为空间上的一组序列，首先集合中的元素必须都存在才能产生集合，如我们无法创建
一个偶数的集合，因为偶数是无穷的，因此集合是无穷的，空间上无法确定集合大小。而流则可以
理解为时间上的一组序列，流中的元素不必全部产生后才可使用，因此，流有按需生产、延迟生产
的特点，我们可以很轻易地创建一个包含所有偶数的流，只不过这个流中的元素永远也输出不完。</p>
<h3 id="外部迭代和内部迭代">外部迭代和内部迭代</h3>
<p>集合中的元素是确定的，并且我们需要自行创建迭代来遍历集合中的所有元素；而流中的元素则
是由内部迭代完成的，迭代交给流来进行有很多好处，首先带来了声明式的简洁，且因为迭代在
内部进行，流的实现者可以为我们提供了迭代优化和并行优化（具体通过java7提供的fork-join
框架实现）</p>
<h3 id="流的操作">流的操作</h3>
<p>流分为中间操作和终端操作两种操作类型。中间操作并不真正操作流中的元素，而是建设起操作流
的流水线，这种流的延迟特性带来了<code class="highlighter-rouge">循环合并</code>以及<code class="highlighter-rouge">短路</code>等优化技巧的用武之地。而终端操作则会
从流水线生成结果。这个结果是任何不是流的值，比如void，List，int等。并且流只能够遍历
一次，所以无法一次链式处理的流操作，需要再次打开流，进行第二次遍历处理。在上述例子中，
filter、sorted、map为中间操作，collect为终端操作。</p>
<h2 id="使用流">使用流</h2>
<p>流提供了许多操作，能够给你快速完成复杂的数据处理，如筛选、切片、映射、查找、匹配和规约。</p>
<h3 id="筛选">筛选</h3>
<p>通过谓词筛选，<code class="highlighter-rouge">filter</code>接口<code class="highlighter-rouge">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>需要
提供一个谓词，而谓词是一个返回<code class="highlighter-rouge">true</code>或者<code class="highlighter-rouge">false</code>的接口，用于根据指定元素t进行条件判断</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public interface Predicate&lt;T&gt; {
    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
}
</code></pre>
</div>
<p>在本例中，我们通过传入<code class="highlighter-rouge">Dish</code>对象的方法引用<code class="highlighter-rouge">Dish::isVegetarian</code>来告诉菜品流，我们要
过滤出所有的素食菜品</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Dish&gt; vegetarianMenu = menu.stream()
                                .filter(Dish::isVegetarian)
                                .collect(toList());
</code></pre>
</div>
<p><code class="highlighter-rouge">Dish</code>对象中判断是否是素食的方法</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public boolean isVegetarian() {
        return vegetarian;
}
</code></pre>
</div>
<p>而根据lambda表达式，过滤方法也可以按如下形式表达</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Dish&gt; vegetarianMenu = menu.stream()
                                .filter(dish -&gt; dish.isVegetarian())
                                .collect(toList());
</code></pre>
</div>
<h3 id="筛选各异的元素">筛选各异的元素</h3>
<p>通过<code class="highlighter-rouge">distinct()</code>方法，我们可以筛选出不重复的元素</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
       .filter(i -&gt; i % 2 == 0)
       .distinct()
       .forEach(System.out::println);
</code></pre>
</div>
<h3 id="截短流">截短流</h3>
<p>通过<code class="highlighter-rouge">limit(3)</code>将流的输出限制为3个，在流的内部实现中，会采用一种叫做<code class="highlighter-rouge">短路</code>的优化，即
无需完整过滤完整个流，只要<code class="highlighter-rouge">filter()</code>方法过滤出3个菜品，即马上停止流的内部遍历，通过
<code class="highlighter-rouge">collect()</code>方法返回列表。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Dish&gt; dishesLimit3 = menu.stream()
                .filter(d -&gt; d.getCalories() &gt; 300)
                .limit(3)
                .collect(toList());
</code></pre>
</div>
<h3 id="跳过元素">跳过元素</h3>
<p>通过<code class="highlighter-rouge">skip(2)</code>方法，返回一个丢弃了前两个元素的流。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Dish&gt; dishesSkip2 = menu.stream()
                .filter(d -&gt; d.getCalories() &gt; 300)
                .skip(2)
                .collect(toList());
</code></pre>
</div>
<h3 id="映射">映射</h3>
<p>映射类似于SQL里筛选出一张表中的某一列数据，通过<code class="highlighter-rouge">map</code>和<code class="highlighter-rouge">flatMap</code>方法，我们可以将流
中的元素结合映射为另一种类型的集合，比如从菜品流<code class="highlighter-rouge">List&lt;Dish&gt;</code>选出所有菜品的名称<code class="highlighter-rouge">List&lt;String&gt;</code>。
<code class="highlighter-rouge">map</code>接口<code class="highlighter-rouge">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code>需要
传入一个<code class="highlighter-rouge">Function</code>类型的函数式接口，这个接口的作用是把传入的参数从一种类型转换为另一种类型，
就菜品转换而言，流内部的循环会通过这个接口把单个<code class="highlighter-rouge">Dish</code>元素转变为<code class="highlighter-rouge">String</code>元素，然后
通过内部迭代器收集对象，最终通过<code class="highlighter-rouge">collect</code>输出为列表或者做其他处理。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public interface Function&lt;T, R&gt; {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}
</code></pre>
</div>
<p>在本例中，我们通过<code class="highlighter-rouge">map</code>方法，将<code class="highlighter-rouge">Dish</code>对象映射为<code class="highlighter-rouge">String</code>对象，即获取菜品的名称，最后
通过<code class="highlighter-rouge">Collectors.toList()</code>方法采集输出为字符串列表。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;String&gt; dishNames = menu.stream()
                             .map(Dish::getName)
                             .collect(toList());
</code></pre>
</div>
<p><code class="highlighter-rouge">Dish</code>对象中获取菜品名称的方法如下</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public String getName() {
        return name;
}
</code></pre>
</div>
<p>下面的例子展示了计算数组中每个单词的长度，通过方法引用<code class="highlighter-rouge">String::length</code>获得每个单词
的长度，返回类型<code class="highlighter-rouge">int</code>通过java的自动装箱操作转换为<code class="highlighter-rouge">Integer</code>类型（自动装箱操作有额外
操作成本，需要进行关注，后续会介绍java8提供的几个原生Stream类型用于提高性能），</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;String&gt; words = Arrays.asList("Hello", "World");
List&lt;Integer&gt; wordLengths = words.stream()
                                 .map(String::length)
                                 .collect(toList());
</code></pre>
</div>
<h4 id="流的扁平化">流的扁平化</h4>
<p><code class="highlighter-rouge">flatMap</code>方法<code class="highlighter-rouge">&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code>
需要传入一个输出转换结果为流的函数方法。即<code class="highlighter-rouge">flatMap</code>首先将输入流中的每个元素，
通过<code class="highlighter-rouge">Function</code>接口转换为对应的流，然后再将所有得到的流连接起来成为一个流。
为了输出单词列表中所有出现的不同字母，我们首先通过<code class="highlighter-rouge">Arrays.stream()</code>方法将输入字符串
转换为<code class="highlighter-rouge">Stream&lt;String&gt;</code>，然后每个单词转换的流进行数据整合，归集为一个<code class="highlighter-rouge">Stream&lt;String&gt;</code>
流，最后通过<code class="highlighter-rouge">distinct()</code>方法筛选流中所有不重复的字母。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>words.stream()
     .flatMap((String line) -&gt; Arrays.stream(line.split("")))
     .distinct()
     .forEach(System.out::println);
</code></pre>
</div>
<h3 id="匹配">匹配</h3>
<ul>
  <li>检查谓词是否至少匹配一个元素：<code class="highlighter-rouge">boolean anyMatch(Predicate&lt;? super T&gt; predicate);</code>
    <div class="highlighter-rouge"><pre class="highlight"><code>menu.stream()
  .anyMatch(Dish::isVegetarian);  // 菜单中是否有一个素菜
</code></pre>
    </div>
  </li>
  <li>检查谓词匹配所有元素：<code class="highlighter-rouge">boolean allMatch(Predicate&lt;? super T&gt; predicate);</code>
    <div class="highlighter-rouge"><pre class="highlight"><code>menu.stream()
  .allMatch(d -&gt; d.getCalories() &lt; 1000);  // 所有菜品卡路里是否小于1000
</code></pre>
    </div>
  </li>
  <li>检查谓词对所有元素均不匹配：<code class="highlighter-rouge">boolean noneMatch(Predicate&lt;? super T&gt; predicate);</code>
    <div class="highlighter-rouge"><pre class="highlight"><code>menu.stream()
  .noneMatch(d -&gt; d.getCalories() &gt;= 1000); // 所有菜品卡路里是否不大于1000
</code></pre>
    </div>
  </li>
</ul>

<p>这三个查找方法均使用到了短路优化，即在满足条件时，无需完整遍历流中所有元素，即可返回结果。</p>
<h3 id="查找元素">查找元素</h3>
<ul>
  <li>查找任意元素：<code class="highlighter-rouge">Optional&lt;T&gt; findAny();</code>
    <div class="highlighter-rouge"><pre class="highlight"><code>Optional&lt;Dish&gt; dish = menu.stream()
          .filter(Dish::isVegetarian).findAny();  // 找出菜单任意一个素菜
dish.ifPresent(d -&gt; System.out.println(d.getName())); // 如果有素菜则打印菜名
</code></pre>
    </div>
  </li>
  <li>查找第一个元素：<code class="highlighter-rouge">Optional&lt;T&gt; findFirst();</code>
    <div class="highlighter-rouge"><pre class="highlight"><code>Optional&lt;Dish&gt; dish = menu.stream()
          .filter(Dish::isVegetarian).findFirst();  // 找出菜单第一个素菜
</code></pre>
    </div>
  </li>
</ul>

<p>查找元素返回的是一个<code class="highlighter-rouge">Optional&lt;T&gt;</code>类型，用于表示对象是否存在，通过
<code class="highlighter-rouge">ifPresent(Consumer&lt;? super T&gt; consumer)</code>方法可以传入一个消费者，当对象存在时，执行消费者的消费动作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface Consumer&lt;T&gt; {
    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
}
</code></pre>
</div>

<h3 id="归约">归约</h3>
<p>归约用来将一系列元素折叠成一个元素，比如对1至100的数字求和，通过归约操作，我们可以不断
对累积值和流中的数字使用加法，从而完成所有数字的累加，最终累积值即为所有元素之和。归约
操作通过<code class="highlighter-rouge">Stream.reduce</code>方法实现。我们先来看一下它的用法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Integer&gt; numbers = Arrays.asList(3,4,5,1,2);
int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);

// 通过Integer提供的求和静态方法sum完成累加
int sum2 = numbers.stream().reduce(0, Integer::sum);
</code></pre>
</div>
<p>该方法有如下三种重载：</p>
<ul>
  <li>提供初始值，以及一个二元操作的方法引用</li>
</ul>

<p>上面例子使用的是该用法，通过提供初始值以及一个函数引用，我们向流提供一种累加的方法，
即我们需要一个整数，初始值为0， 通过<code class="highlighter-rouge">(a, b) -&gt; a + b</code>方法（即<code class="highlighter-rouge">Integer::sum</code>）
不断与流中的元素进行归约计算，最终得到累加和的输出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);
</code></pre>
</div>
<ul>
  <li>仅提供二元操作的方法引用</li>
</ul>

<p>当流为空时，可能会返回空结果，因此方法签名的返回值为一个可选的<code class="highlighter-rouge">Optional&lt;T&gt;</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);
</code></pre>
</div>
<ul>
  <li>更加通用的流归约方法</li>
</ul>

<p>上面两个方法都能通过下面三个参数的方法实现，首先U是我们归约期望得到的目标值类型，
第一个参数给了一个起始值，当流为空的时候用作默认值返回；第二个参数是一个二元函数，
用来将归约中间值以及流中的元素转换为目标值；第三个参数用来对归约中间值以及第二步得到的
目标类型值进行归约计算。
<code class="highlighter-rouge">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator,
                 BinaryOperator&lt;U&gt; combiner);</code></p>

<p>同时，我们也可以通过归约来求出流中的最大值最小值，因为求出流中的最大值最小值也是分别
两两比较流内的数字。下面例子可以计算如何求流的最大值，当流为空时，最大值为0。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>int max = numbers.stream().reduce(0, (a, b) -&gt; Integer.max(a, b));
</code></pre>
</div>
<p>这不一定是你期望的结果，因此可以采用<code class="highlighter-rouge">reduce()</code>方法的单参数重载方法。并根据流非空的情况
进行相应处理。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);
min.ifPresent(System.out::println);
</code></pre>
</div>

<p>关于流的操作，诸如map或者filter等操作会从输入中获取每一个元素进行处理，并且得到0个
或者1个结果，这些操作一般是无状态的，因此可以很容易地并行化。而对于reduce、sum、max
这类操作则需要内部维护一个状态来进行累计结果，因此被称为有状态，所以内部实现的并行策略
会完全不一样，会使用分支/合并框架，即先讲数据分块，分块求和后，最后再将数据合并起来。
对于sort或者distinct这类有状态的操作是通过一个输入流产出对应的输出流，每一个输入数据
进入处理时还需要知道先前处理的历史，因此当流比较大或者无界时，有一些操作就会有问题，比如
将一个质数流进行倒序（数学告诉我们，无穷多的质数无法倒序排序）</p>

<h3 id="数值流">数值流</h3>
<p>数值流是原始类型流的特化流，专门用于处理数值类型，如<code class="highlighter-rouge">InputStream</code>、<code class="highlighter-rouge">DoubleStream</code>、
<code class="highlighter-rouge">LongStream</code>，使用数值流有两个原因，一是通用的流并没有提供数值操作才有的类似sum等方法，
两个对象的sum并没有任何意义，虽然你可以使用<code class="highlighter-rouge">Stream&lt;Integer&gt;</code>的方式处理数值，但是
java的自动装箱机制会带来额外的开销，所以通过专门处理int、double和long型的数值流，
可以带来更高的效率。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
int calories = intStream.sum();

// 数值流转换为对象流
Stream&lt;Integer&gt; stream = intStream.boxed();

// 数值型默认值，原生类型需使用对应的特异化Optional版本，之所以是需要OptionalInt
// 是因为流可能为空，所以不一定存在最大值，所以如果没有最大值时，我们可以显式提供一个。
OptionalInt maxCalories = intStream.max();
int max = maxCalories.orElse(1);
</code></pre>
</div>

<h4 id="数值流的范围">数值流的范围</h4>
<p>通过<code class="highlighter-rouge">rangeClosed(m, n)</code>方法生成从m到n（不包括n）范围的数值流。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>IntStream evenNumbers = IntStream.rangeClosed(1, 100)
                                 .filter(n -&gt; n % 2 == 0);
System.out.println(evenNumbers.count());
</code></pre>
</div>
<h3 id="构建流">构建流</h3>
<p>构建一个流有多种办法，通过从值序列、数组、文件来创建，甚至是生成函数来创建无限流。</p>
<ul>
  <li>生成空流</li>
</ul>

<p><code class="highlighter-rouge">Stream&lt;String&gt; emptyStream = Stream.empty();</code></p>

<ul>
  <li>显式创建流</li>
</ul>

<p><code class="highlighter-rouge">Stream&lt;String&gt; stream = Stream.of("hello", " world", " my", " friends");</code></p>

<ul>
  <li>由数组创建流</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();
</code></pre>
</div>

<ul>
  <li>由文件生成流</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>// 读取data.txt文件并计算使用了多少种不同的单词。
Paths paths = Paths.get("path/data.txt");
long uniqueWords = Files.lines(paths, Charset.defaultCharset())
                        .flatMap(line -&gt; Arrays.stream(line.split(" ")))
                        .distinct()
                        .count();
</code></pre>
</div>

<ul>
  <li>通过函数生成无限流</li>
</ul>

<p>通过<code class="highlighter-rouge">Stream.iterate</code>和<code class="highlighter-rouge">Stream.generate</code>方法可以生成无限流，对于无限流的使用，一般
会通过<code class="highlighter-rouge">limit(n)</code>来限制流的大小，避免出现无穷打印。
<code class="highlighter-rouge">public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f);</code>
iterate通过传入一个初始值seed和一元操作函数引用来迭代产生新的值，首先返回初始值seed，
然后通过初始值seed输入函数引用f，生成第二个值s1，接着通过s1输入f，得到第三个值s2，
以此类推。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 打印10个偶数
Stream.iterate(0, n -&gt; n + 2)
      .limit(10)
      .forEach(System.out::println);
// 创建斐波那契数列
Stream.iterate(new int[]{0, 1}, t -&gt; new int[]{t[1],t[0] + t[1]})
      .limit(10)
      .forEach(t -&gt; System.out.println("(" + t[0] + ", " + t[1] + ")"));
</code></pre>
</div>

<p>与<code class="highlighter-rouge">iterate</code>方法类似，<code class="highlighter-rouge">generate</code>方法是通过接收一个<code class="highlighter-rouge">Supplier&lt;T&gt;</code>的函数引用来生成
新的值。<code class="highlighter-rouge">public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s);</code>，通过方法引用，
我们可以内部维护一个状态，在每次生成数据之后可以更新该状态，从而实现有状态的供应源。
但是在并行流中使用有状态的流是不安全的，应答尽量避免。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 产生10个随机数
Stream.generate(Math::random)
      .limit(10)
      .forEach(System.out::println);

// 避免装箱操作，通过DoubleStream实现
DoubleStream.generate(Math::random)
            .limit(5)
            .forEach(System.out::println);
</code></pre>
</div>

<h3 id="收集">收集</h3>
<p>收集器是一个将数据按指定需求描述进行处理的函数式接口。通过收集器，你可以只通过描述数据
如何收集，而避免亲自实现如何收集。首先看一个根据货币类型分组交易的问题，使用原始的
迭代编码和使用收集器的简洁编码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 通过迭代的方式以Currency为键，对Transaction进行分组
private static void groupImperatively() {
    Map&lt;Currency, List&lt;Transaction&gt;&gt; transByCurrencies = new HashMap&lt;&gt;();
    for (Transaction transaction : transactions) {
        Currency currency = transaction.getCurrency();
        List&lt;Transaction&gt; transForCurrency = transByCurrencies.get(currency);
        if (transForCurrency == null) {
                transForCurrency = new ArrayList&lt;&gt;();
            transByCurrencies.put(currency, transForCurrency);
        }
        transForCurrency.add(transaction);
    }
    System.out.println(transByCurrencies);
}

// 通过java8收集器进行分组
private static void groupFunctionally() {
    Map&lt;Currency, List&lt;Transaction&gt;&gt; transByCurrencies = transactions
        .stream()
        .collect(Collectors.groupingBy(Transaction::getCurrency));
    System.out.println(transByCurrencies);
}
</code></pre>
</div>
<p>从上面的对比看到使用函数式风格的收集器可以更好地维护代码，特别是当还有子分组的情况下，
迭代式的实现子分组会加倍复杂化代码。而通过收集器，则只需要增加一个子收集器即可。可以
更好地复合和重用。而其中所有的收集器，都通过工厂类<code class="highlighter-rouge">Collectors</code>提供。</p>

<ul>
  <li>归约</li>
</ul>

<p>获取菜单中有多少种菜<code class="highlighter-rouge">menu.stream().collect(Collectors.counting());</code>
也可以采用下面更为直接的形式<code class="highlighter-rouge">menu.stream().count();</code></p>

<ul>
  <li>最大最小值</li>
</ul>

<p>通过传入一个比较器，使用工厂类的<code class="highlighter-rouge">maxBy</code>和<code class="highlighter-rouge">minBy</code>方法查找最高或最低卡路里的菜肴。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 获取最高热量的菜品
Comparator&lt;Dish&gt; comparator = Comparator.comparingInt(Dish::getCalories);
Optional&lt;Dish&gt; mostCaloriesDish = menu.stream()
                                .collect(Collectors.maxBy(comparator));
</code></pre>
</div>

<ul>
  <li>汇总</li>
</ul>

<p><code class="highlighter-rouge">Collectors.summingInt</code>方法返回一个”将对象转换为int的函数”的收集器，通过该收集器
来计算菜单中所有菜品的总热量。针对其他原生类型还提供了<code class="highlighter-rouge">summingLong</code>和<code class="highlighter-rouge">summingDouble</code>
方法。而汇总还包含了求平均数<code class="highlighter-rouge">averagingInt</code>方法和对应long、double类型特异方法。为了
能够在一次计算中获取包含最大值、最小值、平均值等在内的所有值，Collectors还提供了
<code class="highlighter-rouge">summarizingInt</code>方法，用于一次性获取对应规约汇总值。同提供long、double特异方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 对菜单所有菜品总热量求和
int total = menu.stream().collect(Collectors.summingInt(Dish::getCalories));

// 平均热量
int average = menu.stream().collect(averagingInt(Dish::getCalories));

// 关于热量的统计值
IntSummaryStatistics statistics = menu.stream()
                        .collect(summarizingInt(Dish::getCalories));
</code></pre>
</div>

<ul>
  <li>连接字符串</li>
</ul>

<p>连接字符串会将流中的所有元素通过指定的分隔符，串成一个字符串。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 根据逗号分隔所有菜品的菜名
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));

// 如果Dish类中有一个toString方法来返回菜名，则无需通过菜品获取名称的映射
String shortMenu = menu.stream().collect(joining());
</code></pre>
</div>

<h4 id="广义的归约汇总">广义的归约汇总</h4>
<p>上述我们讨论的所有收集器，都是一个<code class="highlighter-rouge">Collectors.reducing</code>工厂方法定义的归约过程的
特殊情况。<code class="highlighter-rouge">reducing</code>方法是之前介绍的特殊情况的一般化。可以说，前面介绍的案例仅仅是
为了方便程序员开发而已，但是方便开发人员和可读性可是头等大事！，所以我们可以通过一般
化方法计算菜单的总热量。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//
int totalCalories = menu.stream()
              .collect(reducing(0, Dish::getCalories, Integer::sum)));
</code></pre>
</div>
<p>reducing共有三种重载方法，上面使用的是最基础的方法，首先给定一个起始值0，当流为空的
时候可作为默认值直接返回；第二个参数提供一个Function，用于将流中的数据类型转换为需要
归约的目标数据类型，如将Dish类型转换为int型；第三个参数则是用来进行归约的二元运算函数，
通过起始值0和流中第一个元素的转换类型，进行二元运算得到新值，然后将新值与流中的下一个
元素的转换值，继续进行归约运算，直到流中元素完成归约计算。下面是<code class="highlighter-rouge">reducing</code>的定义。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/*
 * @param &lt;T&gt; the type of the input elements
 * @param &lt;U&gt; the type of the mapped values
 * @param identity the identity value for the reduction (also, the value
 *                 that is returned when there are no input elements)
 * @param mapper a mapping function to apply to each input value
 * @param op a BinaryOperator&lt;U&gt; used to reduce the mapped values
 * @return a Collector implementing the map-reduce operation
 *
 * @see #reducing(Object, BinaryOperator)
 * @see #reducing(BinaryOperator)
 */
public static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,
        Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op);
</code></pre>
</div>

<p>重载的<code class="highlighter-rouge">reducing</code>方法简化了输入流的类型和归约值的类型，即当两者相同时，无需再使用
映射函数，因此提供了仅有初始值和二元函数的方法，
<code class="highlighter-rouge">public static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code>
和仅有归约二元函数的方法，但是需要注意因为没有提供起始值，并且流可能为空，所以返回的
<code class="highlighter-rouge">Collector</code>类型是一个返回<code class="highlighter-rouge">Optional&lt;T&gt;</code>的对象。
<code class="highlighter-rouge">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code></p>

<h4 id="流的归约接口和收集器的归约方法">流的归约接口和收集器的归约方法</h4>
<p>对比<code class="highlighter-rouge">Stream.reduce</code>和<code class="highlighter-rouge">Collectors.reducing</code>，我们可以发现许多类似之处，都存在三种
方法重载，并且使用模式基本一致。主要区别在于<code class="highlighter-rouge">Stream.reduce</code>方法用于直接在流中进行
归约，且其语义是不会改变容器，因此归约的方法均为无状态，从而可以进行高效地并行，而
<code class="highlighter-rouge">Collectors</code>是一个工具类，<code class="highlighter-rouge">Collectors.reducing</code>的目的是返回一个<code class="highlighter-rouge">Collector</code>接口，
通过该接口，我们可以结合<code class="highlighter-rouge">Stream.collect</code>方法，对有状态的操作进行并行归约(使用分支/合并框架)。
因此，<code class="highlighter-rouge">collect</code>方法的语义则是改变容器，从而累积要输出的结果。</p>

<h4 id="收集框架的灵活性">收集框架的灵活性</h4>
<p>可以通过不同的方法执行相同的操作</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 对菜单所有菜品总热量求和，使用多种方法
menu.stream().collect(summingInt(Dish::getCalories));
menu.stream().collect(reducing(0, Dish::getCalories, Integer::sum));
menu.stream().map(Dish::getCalories).reduce(Integer::sum).get();
menu.stream().mapToInt(Dish::getCalories).sum();
</code></pre>
</div>

<p>对于<code class="highlighter-rouge">Collectors.counting</code>方法，实际上是通过<code class="highlighter-rouge">Collectors.reducing</code>方法实现。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public static &lt;T&gt; Collector&lt;T, ?, Long&gt; counting() {
    return reducing(0L, e -&gt; 1L, Long::sum);
}
</code></pre>
</div>
<p>通过上面的例子说明收集器在某种程度上比<code class="highlighter-rouge">Stream</code>接口上直接提供的方法用起来更复杂，但好处
在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。但是这么多方案中，始终选择一个
最专业的方案是我们在实践中推荐的，因为最后一个热量求和方法最简洁，并且因为避免了自动
拆箱操作，所以性能也是最好的。</p>

<h3 id="分组">分组</h3>
<p>通过<code class="highlighter-rouge">Collectors.groupingBy</code>工厂方法返回的收集器，可以轻松完成分组任务。如通过菜品
的类型进行分组并收集。我们可以看到最终结果是一个<code class="highlighter-rouge">Map&lt;Dish.Type, List&lt;Dish&gt;&gt;</code>，
通过<code class="highlighter-rouge">Dish.Type</code>为键，收集到对应的菜品保存在<code class="highlighter-rouge">List&lt;Dish&gt;</code>中。从而通过描述分组简化了
分组的实现，可读性大大提高，开发者不需要自己编写和维护该Map，同时因为分组使用了
分支/合并框架，可以支持高效的并行操作。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>private Map&lt;Dish.Type, List&lt;Dish&gt;&gt; groupDishesByType() {
    return menu.stream().collect(groupingBy(Dish::getType));
}

// 分组方法也有三种重载，下面给出最简单的一种。只需要提供一个分类函数，其中输入是流
中元素的值，输出则是分类依据的键，最终整个流将根据每个元素所属键的不同而分类并收集。
public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;
    groupingBy(Function&lt;? super T, ? extends K&gt; classifier);
</code></pre>
</div>
<h4 id="多级分组">多级分组</h4>
<p>在上例根据菜品类型分组的基础上，再根据菜品热量进行子分组，此时使用的<code class="highlighter-rouge">groupingBy</code>
方法需要第二个参数，即传递用于进行子分组的<code class="highlighter-rouge">Collector</code>收集器。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>private Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt;
                                   groupDishedByTypeAndCaloricLevel() {
    return menu.stream().collect(
        groupingBy(Dish::getType,
            groupingBy((Dish dish) -&gt; {
                if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;
                else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;
                else return CaloricLevel.FAT;
            } )
        )
    );
}
</code></pre>
</div>
<p>而通过传递的收集器类型不同，除了进行子分组外，还能进行诸如计算、映射、收集等操作。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 统计各类菜品的数量。
menu.stream().collect(groupingBy(Dish::getType, counting()));

// 找出各类热量最高的菜品。注意返回Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt;
menu.stream().collect(groupingBy(Dish::getType,
                                maxBy(comparingInt(Dish::getCalories))));
</code></pre>
</div>
<p>上述找出各类热量最高的菜品中，最终我们获得的是一个<code class="highlighter-rouge">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt;</code>
类型，而根据分组的定义可知，分组的菜品绝对不可能为空，因此，我们希望得到更为精确的类型。
通过<code class="highlighter-rouge">collectingAndThen</code>方法以及传入的第二个转换函数来自动执行取值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 找出各类热量最高的菜品。返回Map&lt;Dish.Type, Dish&gt;
menu.stream().collect(groupingBy(Dish::getType,
                collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                Optional::get));
</code></pre>
</div>

<p>对于<code class="highlighter-rouge">groupingBy</code>联合其他类型的收集器，可以通过<code class="highlighter-rouge">Collectors.mapping</code>方法生成，该
方法第一个参数对流中的元素做变换，另一个参数则将对象收集起来，通过变换，从而让接收特定
类型元素的收集器能够适应不同类型的对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(
                                Function&lt;? super T, ? extends U&gt; mapper,
                                Collector&lt;? super U, A, R&gt; downstream);
</code></pre>
</div>
<p>比如我们想知道每一种菜品分别包含了哪一些热量级别，可以通过<code class="highlighter-rouge">mapping</code>传递一个转换函数
以及<code class="highlighter-rouge">toSet()</code>收集器来实现。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>private static Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType() {
    return menu.stream().collect(
            groupingBy(Dish::getType, mapping(
                    dish -&gt; { if (dish.getCalories() &lt;= 400)
                                    return CaloricLevel.DIET;
                    else if (dish.getCalories() &lt;= 700)
                                    return CaloricLevel.NORMAL;
                    else return CaloricLevel.FAT; },
                    toSet() )));
}
</code></pre>
</div>

<h3 id="分区">分区</h3>
<p>分区是通过一个特定谓词（返回一个布尔值的函数）来将流中的元素分为满足条件的一类和不满足
条件的一类，因此可以理解为分组的一种特殊情况，包含仅包含<code class="highlighter-rouge">true</code>和<code class="highlighter-rouge">false</code>两种条件。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt;
                        partitioningBy(Predicate&lt;? super T&gt; predicate);

// 根据是否素食来分区菜品
private Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionByVegeterian() {
    return menu.stream().collect(partitioningBy(Dish::isVegetarian));
}
</code></pre>
</div>
<p>同样分区也支持多级分区，且可以进行分区和分组的多级组合，从而需要使用分区函数的重载版本，
用于在第二个参数中传递子收集器。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public static &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(
  Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream);

 // 根据素食分区，并再进行菜品分类
private Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType() {
    return menu.stream().collect(partitioningBy(Dish::isVegetarian,
                                            groupingBy(Dish::getType)));
}
</code></pre>
</div>

<h3 id="收集器接口">收集器接口</h3>
<p>通过实现收集器接口<code class="highlighter-rouge">Collector</code>，我们可以自定义收集器，从而实现个性化行为。先看一下
该接口的定义，T为流中元素的类型，A为累加器实现的类型，收集器通过该类型来实现状态的改变，
R为收集操作得到的结果类型（通常收集为集合，但也可以是其他类型）</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/*
 * @param &lt;T&gt; the type of input elements to the reduction operation
 * @param &lt;A&gt; the mutable accumulation type of the reduction operation (often
 *            hidden as an implementation detail)
 * @param &lt;R&gt; the result type of the reduction operation
 */
public interface Collector&lt;T, A, R&gt; {
    Supplier&lt;A&gt; supplier();         // 建立新的结果容器 A get();
    BiConsumer&lt;A, T&gt; accumulator(); // 将元素添加到结果容器 void accept(A a, T t);
    Function&lt;A, R&gt; finisher();      // 对结果容器应用最终转换 R apply(A a);
    BinaryOperator&lt;A&gt; combiner();   // 合并两个结果容器 A apply(A a1, A a2);
    Set&lt;Characteristics&gt; characteristics(); // 返回不可变的描述收集器行为的集合
}
</code></pre>
</div>
<p>通过前三个方法，即可满足对流进行顺序归约，增加<code class="highlighter-rouge">combiner</code>方法后，则可以对流进行并行
归约，它会用到合并/分支框架和<code class="highlighter-rouge">Spliterator</code>抽象(一种用于划分任务为更小部分的接口)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/*
 * @param &lt;R&gt; the type of the result
 * @param &lt;A&gt; the intermediate accumulation type of the Collector
 * @param collector the Collector describing the reduction
 * @return the result of the reduction
 * @see #collect(Supplier, BiConsumer, BiConsumer)
 * @see Collectors
 */
&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);

/*
 * @param &lt;R&gt; type of the result
 * @param supplier a function that creates a new result container. For a
 *                 parallel execution, this function may be called
 *                 multiple times and must return a fresh value each time.
 * @param accumulator an associative, non-interfering, stateless function
 *        for incorporating an additional element into a result
 * @param combiner an associative, non-interfering, stateless function
 *        for combining two values, which must be compatible with the
 *        accumulator function
 * @return the result of the reduction
 */
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
                  BiConsumer&lt;R, ? super T&gt; accumulator,
                  BiConsumer&lt;R, R&gt; combiner);
</code></pre>
</div>

<h3 id="附录a-中间操作和终端操作表">附录A 中间操作和终端操作表</h3>
<p>| 操作      | 类型            | 返回类型           | 使用的类型/函数式接口 | 函数描述符    |
| ——– | ————— | —————– | —————— | ———— |
| filter   | 中间             | <code class="highlighter-rouge">Stream&lt;T&gt;</code>       | <code class="highlighter-rouge">Predicate&lt;T&gt;</code>     | T -&gt; boolean |
| distinct | 中间（有状态-无界）| <code class="highlighter-rouge">Stream&lt;T&gt;</code>       |                    |              |</p>

<h3 id="附录b-收集器工具类方法表">附录B 收集器工具类方法表</h3>
<p><code class="highlighter-rouge">toList</code>
<code class="highlighter-rouge">toSet</code>
<code class="highlighter-rouge">toCollection</code></p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <!--<h2 class="footer-heading">小笔记</h2>-->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              by grimkeke
            
            </li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/grimkeke"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">grimkeke</span></a>

          </li>
          

          
          <li>
            <!--<a href="https://twitter.com/grimkeke"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">grimkeke</span></a>
-->
          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <!--<p>simple site to write note.
</p>-->
        <p><a href="/feed.xml">RSS订阅</a></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
