<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2018-02-24T11:58:20+08:00</updated><id>http://0.0.0.0:4000/</id><title type="html">小笔记</title><subtitle>simple site to write note.
</subtitle><author><name>grimkeke</name></author><entry><title type="html">并行数据处理与性能读书笔记</title><link href="http://0.0.0.0:4000/java8/2018/02/23/know-parallel.html" rel="alternate" type="text/html" title="并行数据处理与性能读书笔记" /><published>2018-02-23T14:31:44+08:00</published><updated>2018-02-23T14:31:44+08:00</updated><id>http://0.0.0.0:4000/java8/2018/02/23/know-parallel</id><content type="html" xml:base="http://0.0.0.0:4000/java8/2018/02/23/know-parallel.html">&lt;h2 id=&quot;并行数据处理&quot;&gt;并行数据处理&lt;/h2&gt;
&lt;p&gt;java7之前的数据集合并行处理非常麻烦，通常我们首先需要明确地将数据划分为若干子部分，
第二需要为每一个子部分分配一个独立的线程，第三我们还需要在恰当的时候对这些线程进行同步
来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。java7开始
引入了一个分支/合并的框架，让这些操作更稳定、更不易出错。&lt;/p&gt;
&lt;h3 id=&quot;并行流&quot;&gt;并行流&lt;/h3&gt;
&lt;p&gt;并行流可以通过对集合调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parallelStream&lt;/code&gt;方法来生成。通过并行流，我们可以将集合中的
数据分成多个块，使用不同的线程分别处理各个数据块的流，这样可以将工作分配到多核处理器
的所有内核，让同一个任务操作并行起来。下面以对数字1到n进行累加和的计算为例，说明并行流
的操作和性能优化。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java7之前的迭代式对小于等于n的数字求和
public static long iterativeSum(long n) {
    long result = 0;
    for (long i = 0; i &amp;lt;= n; i++) {
        result += i;
    }
    return result;
}

// java8之后通过流的归约完成数字求和
public static long sequentialSum(long n) {
    return Stream.iterate(1L, i -&amp;gt; i + 1)  // 通过顺序迭代产生流
                 .limit(n)                 // 限制只产生n个数字
                 .reduce(Long::sum)        // 通过求和方法计算流中元素总和
                 .get();                   // 因为不会为空，从Optional得到值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;将顺序流转换为并行流&quot;&gt;将顺序流转换为并行流&lt;/h3&gt;
&lt;p&gt;通过对顺序流调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parallel&lt;/code&gt;方法，可以将其标记转换为并行流。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static long parallelSum(long n) {
    return Stream.iterate(1L, i -&amp;gt; i + 1)
                 .limit(n)
                 .parallel()  // 将顺序流转换为并行流
                 .reduce(Long::sum)
                 .get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在实现中，对顺序流调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parallel&lt;/code&gt;方法并不会改变流本身，而只是在流的内部设置了一个表示
是否期望并行执行的&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;标志位，如果设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，则表示我们期望流操作按照并行的
方式执行。而通过对并行流调用&lt;code class=&quot;highlighter-rouge&quot;&gt;sequential&lt;/code&gt;方法，我们可以将并行流转换为顺序流。注意我们
已经了解流的实现机制，所以如下在同一个流中反复设置流的并行化和串行化的最终结果是以最后
一次调用设置方法为准。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 我们期望先对filter使用串行，然后对map使用并行，但实际上整个流并行执行
// 因为整个流会按最后parallel方法指定的标志进行操作
stream.parallel()
      .filter(...).sequential()
      .map(...).parallel()
      .reduce();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;并行流的线程池&quot;&gt;并行流的线程池&lt;/h3&gt;
&lt;p&gt;并行流使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ForkJoinPool&lt;/code&gt;提供的线程执行子集合的操作，它默认的线程数量是运行环境的处理器
数量，这个值由&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;获得。该方法实际返回的
是可用内核的数量，包括了超线程生成的虚拟内核。使用该默认值对绝大多数情况都是不错的。&lt;/p&gt;

&lt;h3 id=&quot;测量流性能&quot;&gt;测量流性能&lt;/h3&gt;
&lt;p&gt;对于上面通过归约完成数字并行求和的例子，我们期望顺序流可以划分成若干子部分，每个子流
分别在不同的内核执行计算，最后，同一个归约操作会将每个子流的结果合并起来，得到整个
原始流的最终结果。而由于并行操作，我们期望执行时间会比顺序执行要快，下面我们通过一个
性能测试来直观感受一下。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过10次测试取最短耗时评估求和方法的性能。
public static &amp;lt;T, R&amp;gt; long measurePerf(Function&amp;lt;T, R&amp;gt; f, T input) {
    long fastest = Long.MAX_VALUE;
    for (int i = 0; i &amp;lt; 10; i++) {
        long start = System.nanoTime();
        R result = f.apply(input);
        long duration = (System.nanoTime() - start) / 1_000_000;
        System.out.println(&quot;Result: &quot; + result);
        if (duration &amp;lt; fastest) fastest = duration;
    }
    return fastest;
}

// 串行求和1到1千万
measurePerf(ParallelStreams::sequentialSum, 10_000_000L);

// 并行求和1到1千万
measurePerf(ParallelStreams::parallelSum, 10_000_000L);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行结果可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;sequentialSum&lt;/code&gt;方法耗时161ms，而&lt;code class=&quot;highlighter-rouge&quot;&gt;parallelSum&lt;/code&gt;耗时493ms。居然并行
执行的耗时更长，这个结果和我们期望的不一样，而实际上这里有两个问题。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;生成的是装箱操作的对象，而对象必须进行拆箱操作才能求和，装箱拆箱操作极大
增加了运算量。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;方法很难划分为多个独立子数据块来进行并行操作，因为iterate方法是有状态的
顺序迭代，每一次新迭代结果的计算都要依赖前一次的迭代结果。
因此，将&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;操作并行化会导致多个线程同步顺序执行，要求每次操作在不同的线程上执行，
实际上增加了处理开销。所以我们在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parallel&lt;/code&gt;方法之前，需要清除知晓背后的数据操作，
是否适合并行化。
    &lt;h4 id=&quot;更为有效的方法&quot;&gt;更为有效的方法&lt;/h4&gt;
    &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;LongStream.rangeClosed&lt;/code&gt;方法，我们首先避免了装箱拆箱操作，其次&lt;code class=&quot;highlighter-rouge&quot;&gt;rangeClosed&lt;/code&gt;
方法产生的数字范围是很容易拆分为独立的小块，如生成范围[1,20]的数字序列，可以轻易划分为
[1,5],[6,10],[11,15],[16,20]的独立子序列，从而可以分配到多个线程并行执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 使用特化流并使用无状态的rangeClosed方法进行顺序求和
public static long rangedSum(long n) {
    return LongStream.rangeClosed(1, n)
                     .reduce(Long::sum)
                     .getAsLong();
}

// 使用特化流并使用无状态的rangeClosed方法进行并行求和
public static long parallelRangedSum(long n) {
    return LongStream.rangeClosed(1, n)
                     .parallel()
                     .reduce(Long::sum)
                     .getAsLong();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行结果可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;rangedSum&lt;/code&gt;方法耗时28ms，而&lt;code class=&quot;highlighter-rouge&quot;&gt;parallelRangedSum&lt;/code&gt;耗时9ms。从而我们
得到了一个更为快捷的并行归约算法。&lt;/p&gt;
&lt;h3 id=&quot;使用并行流的注意点&quot;&gt;使用并行流的注意点&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;对流做递归划分，把每个子流的归纳操作分配到不同的线程上去，然后再把这些操作的结果合并
成一个值。在多个内核之间移动数据的代价可能会比想象的大，因此需要保证任务在内核中并行
执行工作的时间要比在内核之间传输数据的时间长。&lt;/li&gt;
  &lt;li&gt;对流做并行处理，一定要保证划分的任务是无状态的，以免出现竞争问题，而对竞争资源使用同步
机制就会大大减弱并行的执行效率，所以选择正确的数据结构以及正确的数据划分方式是正确并行
优化的前提。要考虑流背后的数据结构是否易于分解。&lt;/li&gt;
  &lt;li&gt;如果有疑问，就测量耗时。因为将顺序流转换为并行流是轻而易举的事情（但并不一定能提高效率），
所以在考虑使用顺序流和并行流时，可以采用适量的基准来检查其性能。&lt;/li&gt;
  &lt;li&gt;对数字留意装箱机制。自动装箱和拆箱操作会大大降低性能，所以应该使用原始流来避免装箱。&lt;/li&gt;
  &lt;li&gt;有一些操作本身在并行流上执行的性能就比顺序执行差，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;findFirst&lt;/code&gt;等依赖
元素顺序的操作。而&lt;code class=&quot;highlighter-rouge&quot;&gt;findAny&lt;/code&gt;会比&lt;code class=&quot;highlighter-rouge&quot;&gt;findFirst&lt;/code&gt;性能好，因为它不一定要按照顺序来执行，所以
我们可以通过对流调用&lt;code class=&quot;highlighter-rouge&quot;&gt;unordered&lt;/code&gt;方法来把流标记为无序流，这样通过对无序流调用如&lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt;
操作就会比对有序流调用该操作更高效。&lt;/li&gt;
  &lt;li&gt;对于较小的数据量，选择并行流几乎从来都不是一个很好的决定，并行处理少数数据的好处还
抵不上并行化造成的额外开销。&lt;/li&gt;
  &lt;li&gt;流自身的特点，以及流水线的中间操作修改流的方式，都可能会改变分解过程的性能。比如将
一个流分成相等大小的两部分，这样每一部分都能高效并行执行，但是筛选操作可能丢弃的元素个数
是未知的，因此划分出来的两个子流经过筛选后的大小是未知的。&lt;/li&gt;
  &lt;li&gt;还要考虑终端操作中合并步骤的代价是大是小（比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;接口中的&lt;code class=&quot;highlighter-rouge&quot;&gt;combiner&lt;/code&gt;方法）。
如果合并结果的代价很大，那么组合每个子流产生的部分结果所付出的代价可能就会超过并行流
得到的性能提升。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;分支合并框架&quot;&gt;分支/合并框架&lt;/h3&gt;
&lt;p&gt;分支/合并框架的目的是用递归的方式将可以并行的任务拆分为更小的任务，然后每个子任务的结果
合并起来生成最终结果。它是&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;接口的一个实现，它把任务分配给线程池
（默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;ForkJoinPool&lt;/code&gt;）中的线程进行工作。&lt;/p&gt;
&lt;h4 id=&quot;使用recursivetask&quot;&gt;使用RecursiveTask&lt;/h4&gt;
&lt;p&gt;通过继承抽象类&lt;code class=&quot;highlighter-rouge&quot;&gt;RecursiveTask&amp;lt;V&amp;gt;&lt;/code&gt;，我们可以创建能够进行分支/合并的任务，并且提交到
这个线程池中并行执行。泛型&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;为任务的返回值类型，如果任务无返回值，则可以继承抽象类
&lt;code class=&quot;highlighter-rouge&quot;&gt;RecursiveAction&lt;/code&gt;。两者仅需要实现唯一的抽象方法&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * A recursive result-bearing {@link ForkJoinTask}.
 * For a classic example, here is a task computing Fibonacci numbers:
 * class Fibonacci extends RecursiveTask&amp;lt;Integer&amp;gt; {
 *   final int n;
 *   Fibonacci(int n) { this.n = n; }
 *   Integer compute() {
 *     if (n &amp;lt;= 1)
 *       return n;
 *     Fibonacci f1 = new Fibonacci(n - 1);
 *     f1.fork();
 *     Fibonacci f2 = new Fibonacci(n - 2);
 *     return f2.compute() + f1.join();
 *   }
 * }}
 */
public abstract class RecursiveTask&amp;lt;V&amp;gt; extends ForkJoinTask&amp;lt;V&amp;gt; {
    /**
     * The result of the computation.
     */
    V result;

    /**
     * The main computation performed by this task.
     * @return the result of the computation
     */
    protected abstract V compute();
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个方法定义了将任务拆分为子任务的逻辑，以及当任务无法拆分或不方便拆分时，生成单个
子任务结果的逻辑。其结果就是我们需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;方法中按如下伪代码模板来编写实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (任务足够小或者不可分) {
    顺序计算该任务
} else {
    将任务分成两个子任务
    递归调用本方法，拆分每个子任务，等待所有子任务完成
    合并每个子任务的结果
}

// 对上例求斐波那契数列套用compute模板的实现如下
if (n &amp;lt;= 1) {   // 初始两个数字0和1是不可分任务，直接返回
    return n;
} else {        // 其他可分割任务的情况
    Fibonacci f1 = new Fibonacci(n - 1);  // 求比n小1的斐波那契数值
    f1.fork();                            // 把该任务分配到线程池处理
    Fibonacci f2 = new Fibonacci(n - 2);  // 求比n小2的斐波那契数值
    Integer r2 = f2.compute();            // 递归调用compute方法拆分任务拿结果
    Integer r1 = f1.join();               // 等待先前提交到线程池的子任务的结果
    return r2 + r1;                       // 合并子任务的结果
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对于使用分支/合并框架并行计算数字1到n的和。我们使用的数据划分方式为当数组大小不超过
10000时，通过顺序累加计算得到结果，否则进行任务划分。以下为完整的对小于等于n的自然数
并行求和的代码实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ForkJoinSumCalculator extends RecursiveTask&amp;lt;Long&amp;gt; {
    public static final ForkJoinPool FORK_JOIN_POOL = new ForkJoinPool();
    public static final long THRESHOLD = 10_000;
    private final long[] numbers;
    private final int start;
    private final int end;

    public ForkJoinSumCalculator(long[] numbers) {
        this(numbers, 0, numbers.length);
    }

    private ForkJoinSumCalculator(long[] numbers, int start, int end) {
        this.numbers = numbers;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        if (length &amp;lt;= THRESHOLD) {
            return computeSequentially();
        }
        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers
                                                , start, start + length/2);
        leftTask.fork();
        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(
                                            numbers, start + length/2, end);
        Long rightResult = rightTask.compute();
        Long leftResult = leftTask.join();
        return leftResult + rightResult;
    }

    private long computeSequentially() {
        long sum = 0;
        for (int i = start; i &amp;lt; end; i++) {
            sum += numbers[i];
        }
        return sum;
    }

    public static long forkJoinSum(long n) {
        long[] numbers = LongStream.rangeClosed(1, n).toArray();
        ForkJoinTask&amp;lt;Long&amp;gt; task = new ForkJoinSumCalculator(numbers);
        return FORK_JOIN_POOL.invoke(task);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;使用分支合并框架的注意点&quot;&gt;使用分支/合并框架的注意点&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;因为对一个任务调用&lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;方法会阻塞调用方，直到被调用任务返回结果。因此我们需要在
两个子任务的计算都开始后再调用它，否则每个子任务都需要等待先前子任务执行完成后才开始执行，
无法达到并行执行的效果。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForkJoinPool&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke&lt;/code&gt;方法只是针对顺序代码来启动计算的，在递归任务的内部，应该
严格按照&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;代码框架，直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;方法，来直接将任务添加到线程池中。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;的实现中，我们划分了两个子任务，对其中一个子任务调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;，使其在
线程池中执行，但是对第二个子任务，我们直接调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;在当前进程中递归执行，这样
的目的是因为在当前线程中执行可以减少一次从线程池分配线程进行任务调度执行的开销，在当前
线程中继续执行另一个子任务的效率会更高。&lt;/li&gt;
  &lt;li&gt;使用分支/合并框架的并行计算对调试会比较棘手，因为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;compute&lt;/code&gt;的线程并不是概念上
的调用方，而调用方是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;方法的那个。&lt;/li&gt;
  &lt;li&gt;和并行流一样，使用分支/合并框架并不一定能比顺序计算快。一个任务只有能独立划分为若干
子任务，才能让性能在并行计算时有所提升，并且并行计算任务的时间需要长于任务划分的时间才
可能发挥并行优势。一个常用的方法是将输入/输出操作和计算操作分别放入不同的任务。此外比较
同一算法的顺序和并行执行的性能时还需要考虑”预热”等其他因素，比如测试算法性能之前我们都
会重复跑几遍程序，这样字节码才会被JIT编辑器优化为机器码，因为我们需要比较的是机器码的
执行效率，而不是字节码解释执行的运行效率。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;工作窃取&quot;&gt;工作窃取&lt;/h3&gt;
&lt;p&gt;通常，我们将任务划分为大量执行时间相同的小任务是一个好的选择。在理想的情况下，划分
出并行任务时，我们希望所有的CPU内核都能同样繁忙，而不是有的内核完成所有任务的执行，而
其他内核正忙于处理队列中的任务，因为每个任务的执行时间实际上会依赖磁盘甚至外部服务，造成
运行时间并不可知。因此将任务划分为大量小任务有利于所有内核持续同时执行任务。并且在分支/合并
框架的实现中，采用了一种叫做工作窃取（work stealing）的技术，即所有的内核均维护一个
双向任务队列，当某个内核执行完成它的任务队列后，它可以随机从其他还在运行任务的内核队列中
窃取队尾的一个任务，从而继续执行下去，直到所有的任务均执行完成，这样可以有助于更好地
平衡工作线程的负载。&lt;/p&gt;
&lt;h3 id=&quot;spliterator拆分任务&quot;&gt;Spliterator拆分任务&lt;/h3&gt;
&lt;p&gt;在上述例子中，我们都是通过手工决定如何拆分任务，而对于并行流，我们并没有指定如何把流拆分
为子流，这说明有一种自动拆分机制完成了任务划分。这就是java8新加入的接口&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;。
它的名称为”可分迭代器”，和&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;一样，也是用来遍历数据源中的元素，但是它是为了
并行执行而设计，而且我们大多数情况下也无需编写自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;，但了解一下它的实现
方式会让我们对流的工作原理有更深入的了解。java8已经为所有的集合元素提供了一个默认的
可分迭代器的实现，如&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;内部实现了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayListSpliterator&lt;/code&gt;用于对顺序列表的
自动划分。下面看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;接口的定义。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Spliterator&amp;lt;T&amp;gt; {
    boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action);
    Spliterator&amp;lt;T&amp;gt; trySplit();
    long estimateSize();
    int characteristics();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;泛型&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;需要遍历的元素类型，&lt;code class=&quot;highlighter-rouge&quot;&gt;tryAdvance&lt;/code&gt;方法当还有数据可以划分是返回
&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;trySplit&lt;/code&gt;方法可以把一些元素划分出去给第二个&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;，让两个任务并行
执行；同时&lt;code class=&quot;highlighter-rouge&quot;&gt;estimateSize&lt;/code&gt;方法会用来评估还剩下多少元素需要遍历，即使无法精确计算，能够
快速计算一个值也有利于让任务划分均匀一点。&lt;code class=&quot;highlighter-rouge&quot;&gt;characteristics&lt;/code&gt;类似于收集器接口中的同名
方法，用于描述可分迭代器的一些划分特性，只不过返回的是&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;型而不是枚举集合。&lt;/p&gt;
&lt;h4 id=&quot;spliterator的拆分过程&quot;&gt;Spliterator的拆分过程&lt;/h4&gt;
&lt;p&gt;将数据源拆分为多个子部分是一个递归的操作过程，首先对一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;trySplit&lt;/code&gt;，
生成第二个&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;，第二步对这两个&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;再分别调用&lt;code class=&quot;highlighter-rouge&quot;&gt;trySplit&lt;/code&gt;，结果得到
四个&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;，最终框架会递归调用直到&lt;code class=&quot;highlighter-rouge&quot;&gt;trySplit&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;，于是任务不会继续拆分，
整个任务的递归划分结束。而在任务拆分过程中，&lt;code class=&quot;highlighter-rouge&quot;&gt;characteristics&lt;/code&gt;方法中的特性会对任务的
划分造成影响。&lt;/p&gt;
&lt;h3 id=&quot;实现自己的spliterator&quot;&gt;实现自己的Spliterator&lt;/h3&gt;

&lt;h3 id=&quot;附录a-通过benchmark框架评估性能&quot;&gt;附录A 通过Benchmark框架评估性能&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@State(Scope.Thread)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Fork(value=2, jvmArgs={&quot;-Xms4G&quot;, &quot;-Xmx4G&quot;})
@Measurement(iterations=2)
@Warmup(iterations=3)
public class ParallelStreamBenchmark {
    private static final long N = 10_000_000L;

    @Benchmark
    public long iterativeSum() {
        long result = 0;
        for (long i = 1L; i &amp;lt;= N; i++) {
            result += i;
        }
        return result;
    }

    @Benchmark
    public long sequentialSum() {
        return Stream.iterate( 1L, i -&amp;gt; i + 1 ).limit(N)
                     .reduce( 0L, Long::sum );
    }

    @Benchmark
    public long parallelSum() {
        return Stream.iterate(1L, i -&amp;gt; i + 1).limit(N)
                     .parallel().reduce( 0L, Long::sum);
    }

    @Benchmark
    public long rangedSum() {
        return LongStream.rangeClosed( 1, N ).reduce( 0L, Long::sum );
    }

    @Benchmark
    public long parallelRangedSum() {
        return LongStream.rangeClosed(1, N).parallel().reduce( 0L, Long::sum);
    }

    @TearDown(Level.Invocation)
    public void tearDown() {
        System.gc();
    }
}

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jmh-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.17.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jmh-generator-annprocess&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.17.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
      &amp;lt;execution&amp;gt;
        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
        &amp;lt;goals&amp;gt;
          &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
        &amp;lt;/goals&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;finalName&amp;gt;benchmarks&amp;lt;/finalName&amp;gt;
          &amp;lt;transformers&amp;gt;
            &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.
                                         resource.ManifestResourceTransformer&quot;&amp;gt;
              &amp;lt;mainClass&amp;gt;org.openjdk.jmh.Main&amp;lt;/mainClass&amp;gt;
            &amp;lt;/transformer&amp;gt;
          &amp;lt;/transformers&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
  &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;maven package&lt;/code&gt;打包，然后通过运行&lt;code class=&quot;highlighter-rouge&quot;&gt;java -jar benchmarks.jar&lt;/code&gt;执行基准测试。
或通过&lt;code class=&quot;highlighter-rouge&quot;&gt;IntelliJ IDEA&lt;/code&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;org.openjdk.jmh.Main&lt;/code&gt;类为执行主函数，在IDE中执行基准测试。
在我的机器运行最终运行结果如下。从下面测试可以看到，使用原生顺序累加方式是最快的，甚至
比通过分支/合并框架并行任务还要快。（疑问：why？）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Run complete. Total time: 00:01:49
Benchmark                                  Mode  Cnt    Score    Error  Units
ParallelStreamBenchmark.iterativeSum       avgt    4    4.834 ±  0.727  ms/op
ParallelStreamBenchmark.parallelRangedSum  avgt    4    5.355 ± 22.860  ms/op
ParallelStreamBenchmark.parallelSum        avgt    4  153.851 ± 80.647  ms/op
ParallelStreamBenchmark.rangedSum          avgt    4    6.218 ±  0.669  ms/op
ParallelStreamBenchmark.sequentialSum      avgt    4  138.467 ± 64.056  ms/op
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>grimkeke</name></author><summary type="html">并行数据处理 java7之前的数据集合并行处理非常麻烦，通常我们首先需要明确地将数据划分为若干子部分， 第二需要为每一个子部分分配一个独立的线程，第三我们还需要在恰当的时候对这些线程进行同步 来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。java7开始 引入了一个分支/合并的框架，让这些操作更稳定、更不易出错。 并行流 并行流可以通过对集合调用parallelStream方法来生成。通过并行流，我们可以将集合中的 数据分成多个块，使用不同的线程分别处理各个数据块的流，这样可以将工作分配到多核处理器 的所有内核，让同一个任务操作并行起来。下面以对数字1到n进行累加和的计算为例，说明并行流 的操作和性能优化。 ``` // java7之前的迭代式对小于等于n的数字求和 public static long iterativeSum(long n) { long result = 0; for (long i = 0; i &amp;lt;= n; i++) { result += i; } return result; }</summary></entry><entry><title type="html">Stream读书笔记</title><link href="http://0.0.0.0:4000/java8/2018/01/14/know-stream-api.html" rel="alternate" type="text/html" title="Stream读书笔记" /><published>2018-01-14T11:57:44+08:00</published><updated>2018-01-14T11:57:44+08:00</updated><id>http://0.0.0.0:4000/java8/2018/01/14/know-stream-api</id><content type="html" xml:base="http://0.0.0.0:4000/java8/2018/01/14/know-stream-api.html">&lt;h2 id=&quot;什么是流&quot;&gt;什么是流&lt;/h2&gt;
&lt;p&gt;流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询
的语句，而不是亲自实现一个查询功能）。对比面向集合，亲自来实现集合操作，通过流，
开发者可以关注于实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询菜品列表
中热量小于400的菜品名称，并且根据菜品热量排序。java7的方法为面向集合、根据语义实现，
即首先遍历所有的菜品，找出热量小于400的菜品并添加到临时列表，根据热量排序，然后再创建
一个列表用于提取菜品的名称。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava7(List&amp;lt;Dish&amp;gt; dishes){
    List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;();
    for(Dish d: dishes){
        if(d.getCalories() &amp;lt; 400){
            lowCaloricDishes.add(d);
        }
    }

    Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() {
        public int compare(Dish d1, Dish d2){
            return Integer.compare(d1.getCalories(), d2.getCalories());
        }
    });

    List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;();
    for(Dish d: lowCaloricDishes){
        lowCaloricDishesName.add(d.getName());
    }
    return lowCaloricDishesName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而java8的流操作就很直观，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;stream&lt;/code&gt;方法，将菜品列表转换为菜品流，接着通过&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;
过滤，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted&lt;/code&gt;按照热量排序，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;将菜品列表映射为名称列表，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;
收集保存为列表。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava8(List&amp;lt;Dish&amp;gt; dishes){
    return dishes.stream()  // 列表转换为流
            .filter(d -&amp;gt; d.getCalories() &amp;lt; 400) // 过滤热量小于400的菜品
            .sorted(Comparator.comparing(Dish::getCalories)) // 按热量排序
            .map(Dish::getName) // 对排序后的每一个菜品调用获取菜名的方法
            .collect(Collectors.toList());  // 通过toList收集器收集为列表
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而将流操作转变为并行操作也非常简单，只需将&lt;code class=&quot;highlighter-rouge&quot;&gt;stream&lt;/code&gt;方法修改为&lt;code class=&quot;highlighter-rouge&quot;&gt;parallelStream&lt;/code&gt;方法
即可。流默认会根据当前运行机器的内核数来创建任务并行执行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava8(List&amp;lt;Dish&amp;gt; dishes){
    return dishes.parallelStream()  // 创建一个并行流
            .filter(d -&amp;gt; d.getCalories() &amp;lt; 400)
            .sorted(Comparator.comparing(Dish::getCalories))
            .map(Dish::getName)
            .collect(Collectors.toList());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;除了声明式地表述数据操作之外，流的编写模式是链式的，即通过一系列方法组合成操作流水线。
而在流的内部，每个处理节点的操作也像流水线一样并行处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           lamdba             lambda             lambda
             +                   +                  +
             |                   |                  |
menu    +----v-----+       +-----v----+       +-----v----+      +---------+
+-------&amp;gt;  filter  +-------&amp;gt;  sorted  +-------&amp;gt;   map    +------&amp;gt; collect |
        +----------+       +----------+       +----------+      +---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;即流有如下三个特点：声明式、可复合（链式）、可并行。&lt;/p&gt;

&lt;h3 id=&quot;流与集合的理解&quot;&gt;流与集合的理解&lt;/h3&gt;
&lt;p&gt;集合可以理解为空间上的一组序列，首先集合中的元素必须全部存在才能成为集合，所以我们无法
创建诸如偶数集合，因为偶数是无穷的，无穷多的元素在空间上无法确定集合大小。而流则可以理解
为时间上的一组序列，流中的元素不必等到全部产生后就能使用。因此，流有按需生产、延迟生产
的特点，我们可以很轻易地创建一个包含所有偶数的流，只不过这个流中的元素永远也输出不完。&lt;/p&gt;

&lt;h4 id=&quot;外部迭代和内部迭代&quot;&gt;外部迭代和内部迭代&lt;/h4&gt;
&lt;p&gt;集合中的元素是确定的，并且我们需要自行创建迭代来遍历集合中的所有元素；而流中的元素则
是由内部迭代完成的，迭代交给流来进行有很多好处，首先带来了声明式的简洁，且因为迭代在
内部进行，流的实现者可以为我们提供了迭代优化和并行优化（通过java7提供的fork-join框架实现）&lt;/p&gt;

&lt;h4 id=&quot;流的操作&quot;&gt;流的操作&lt;/h4&gt;
&lt;p&gt;流分为中间操作和终端操作两种操作类型。中间操作并不真正操作流中的元素，而是建设起操作流
的流水线，这种流的延迟特性带来了”循环合并”以及”短路”等优化技巧的用武之地。而终端操作则会
从流水线生成结果。这个结果是任何不是流的值，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;等。并且流只能够遍历
一次，所以无法一次链式处理的流操作，需要再次打开流，进行第二次遍历处理。在上述例子中，
&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;为中间操作，&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;为终端操作。&lt;/p&gt;

&lt;h2 id=&quot;使用流&quot;&gt;使用流&lt;/h2&gt;
&lt;p&gt;流提供了许多操作，能够给你快速完成复杂的数据处理，如筛选、切片、映射、查找、匹配和规约。&lt;/p&gt;

&lt;h3 id=&quot;筛选&quot;&gt;筛选&lt;/h3&gt;
&lt;p&gt;通过谓词筛选满足条件的元素，接口&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate)&lt;/code&gt;
需要提供一个谓词，而谓词是一个返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的接口，用于根据指定元素t进行条件判断，
经过&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;过滤后，流中只有满足条件的元素才会保留下来。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Predicate&amp;lt;T&amp;gt; {
    /**
     * Evaluates this predicate on the given argument.
     * @param t the input argument
     * @return true if the input argument matches the predicate,
     * otherwise false
     */
    boolean test(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在本例中，我们通过传入&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象的方法引用&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish::isVegetarian&lt;/code&gt;来告诉菜品流，我们要
过滤出所有的素食菜品&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream()
                                .filter(Dish::isVegetarian)
                                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象中判断是否是素食的方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isVegetarian() {
    return vegetarian;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而根据lambda表达式，过滤方法也可以按如下形式表达，只要满足谓词的方法签名即可。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream()
                                .filter(dish -&amp;gt; dish.isVegetarian())
                                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;筛选各异的元素&quot;&gt;筛选各异的元素&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;distinct()&lt;/code&gt;方法，我们可以筛选出不重复的元素&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
       .filter(i -&amp;gt; i % 2 == 0)
       .distinct()
       .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;截短流&quot;&gt;截短流&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;limit(3)&lt;/code&gt;将流的输出限制为3个，在流的内部实现中，会采用一种叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;短路&lt;/code&gt;的优化，即
无需完整遍历整个流，只要&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;方法过滤出3个菜品，即马上停止流的内部遍历，通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;方法返回列表。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; dishesLimit3 = menu.stream()
                .filter(d -&amp;gt; d.getCalories() &amp;gt; 300)
                .limit(3)
                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;跳过元素&quot;&gt;跳过元素&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;skip(2)&lt;/code&gt;方法，返回一个丢弃了前两个元素的流。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; dishesSkip2 = menu.stream()
                .filter(d -&amp;gt; d.getCalories() &amp;gt; 300)
                .skip(2)
                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;映射&quot;&gt;映射&lt;/h3&gt;
&lt;p&gt;映射类似于SQL里筛选出一张表中的某一列数据，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;方法，我们可以将流
中的元素结合映射为另一种类型的集合，比如从菜品流&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Dish&amp;gt;&lt;/code&gt;选出所有菜品的名称&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;。
&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;接口&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper)&lt;/code&gt;需要
传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;类型的函数式接口，这个接口的作用是把传入的参数从一种类型转换为另一种类型，
就菜品转换而言，流内部的循环会通过这个接口把单个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;元素转变为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;元素，然后
通过内部迭代器收集对象，最终通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;输出为列表或者做其他处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Function&amp;lt;T, R&amp;gt; {
    /**
     * Applies this function to the given argument.
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在本例中，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象映射为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象，即获取菜品的名称，最后
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.toList()&lt;/code&gt;收集器输出为字符串列表。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; dishNames = menu.stream()
                             .map(Dish::getName)
                             .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象中获取菜品名称的方法如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public String getName() {
    return name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面的例子展示了计算数组中每个单词的长度，通过方法引用&lt;code class=&quot;highlighter-rouge&quot;&gt;String::length&lt;/code&gt;获得每个单词
的长度，返回类型&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;通过java的自动装箱机制转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;类型（自动装箱操作有额外
操作成本，需要进行关注，后续会介绍java8提供的几个原生Stream类型用于提高性能），&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);
List&amp;lt;Integer&amp;gt; wordLengths = words.stream()
                                 .map(String::length)
                                 .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;流的扁平化&quot;&gt;流的扁平化&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&lt;/code&gt;
需要传入一个输出转换结果为流的函数方法。即&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;首先将输入流中的每个元素，
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;接口转换为对应的流，然后再将所有得到的流连接起来成为一个流。
为了输出单词列表中所有出现的不同字母，我们首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays.stream()&lt;/code&gt;方法将输入字符串
转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;，然后对每个单词转换的流进行数据整合，归集为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;
流，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;distinct()&lt;/code&gt;方法筛选流中所有不重复的字母。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;words.stream()
     .flatMap((String line) -&amp;gt; Arrays.stream(line.split(&quot;&quot;)))
     .distinct()
     .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;匹配&quot;&gt;匹配&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;检查谓词是否至少匹配一个元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .anyMatch(Dish::isVegetarian);  // 菜单中是否有一个素菜
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;检查谓词匹配所有元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .allMatch(d -&amp;gt; d.getCalories() &amp;lt; 1000);  // 所有菜品热量是否均小于1000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;检查谓词对所有元素均不匹配：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .noneMatch(d -&amp;gt; d.getCalories() &amp;gt;= 1000); // 所有菜品热量是否均小于1000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三个查找方法均使用到了短路优化，即在满足条件时，无需完整遍历流中所有元素，即可返回结果。&lt;/p&gt;

&lt;h3 id=&quot;查找元素&quot;&gt;查找元素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;查找任意元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt; findAny();&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Dish&amp;gt; dish = menu.stream()
                        .filter(Dish::isVegetarian)
                        .findAny();  // 找出菜单任意一个素菜
dish.ifPresent(d -&amp;gt; System.out.println(d.getName())); // 如果有素菜则打印菜名
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查找第一个元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt; findFirst();&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Dish&amp;gt; dish = menu.stream()
                        .filter(Dish::isVegetarian)
                        .findFirst();  // 找出菜单第一个素菜
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查找元素返回的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;类型，用于表示对象可能不存在，通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer)&lt;/code&gt;方法可以传入一个消费者，当对象存在时，
执行对象消费动作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Consumer&amp;lt;T&amp;gt; {
    /**
     * Performs this operation on the given argument.
     * @param t the input argument
     */
    void accept(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;归约&quot;&gt;归约&lt;/h3&gt;
&lt;p&gt;归约用来将一系列元素折叠成一个元素，比如对1至100的数字求和，通过归约操作，我们可以不断
对累积值和流中的数字使用加法，从而完成所有数字的累加，最终累积值即为所有元素之和。归约
操作通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.reduce&lt;/code&gt;方法实现。我们先来看一下它的用法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(3,4,5,1,2);
int sum = numbers.stream().reduce(0, (a, b) -&amp;gt; a + b);

// 通过Integer提供的求和静态方法sum完成累加
int sum2 = numbers.stream().reduce(0, Integer::sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该方法有如下三种重载：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;提供初始值，以及一个二元操作的方法引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面例子使用的是该用法，通过提供初始值以及一个函数引用，我们向流提供一种累加的方法，
即我们需要一个整数，初始值为0， 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;(a, b) -&amp;gt; a + b&lt;/code&gt;方法（即&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer::sum&lt;/code&gt;）
不断与流中的元素进行归约计算，最终得到累加和的输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);

public interface BinaryOperator&amp;lt;T&amp;gt; extends BiFunction&amp;lt;T,T,T&amp;gt; {
}

public interface BiFunction&amp;lt;T, U, R&amp;gt; {
    /**
     * Applies this function to the given arguments.
     * @param t the first function argument
     * @param u the second function argument
     * @return the function result
     */
    R apply(T t, U u);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;仅提供二元操作的方法引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当流为空时，可能会返回空结果，因此方法签名的返回值为一个可选的&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;更加通用的流归约方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面两个方法都能通过下面三个参数的方法实现，首先U是我们归约期望得到的目标值类型，
第一个参数给了一个起始值，当流为空的时候用作默认值返回；第二个参数是一个二元函数，
用来将归约中间值以及流中的元素转换为目标值；第三个参数用来对归约中间值以及第二步得到的
目标类型值进行归约计算。
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;U&amp;gt; U reduce(U identity, BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator,
                 BinaryOperator&amp;lt;U&amp;gt; combiner);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同时，我们也可以通过归约来求出流中的最大值最小值，因为求出流中的最大值最小值也是分别
两两比较流内的数字。下面例子可以计算如何求流的最大值，当流为空时，最大值为0。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int max = numbers.stream().reduce(0, (a, b) -&amp;gt; Integer.max(a, b));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这不一定是你期望的结果，因此可以采用&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;方法的单参数重载方法。并根据流非空的情况
进行相应处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Integer&amp;gt; min = numbers.stream().reduce(Integer::min);
min.ifPresent(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于流的操作，诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;等操作会从输入中获取每一个元素进行处理，并且得到0个
或者1个结果，这些操作一般是无状态的，因此可以很容易地并行化。而对于&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt;
这类操作则需要流内部维护一个状态来进行累计结果，因此被称为有状态，所以内部实现的并行策略
会完全不一样，例如使用分支/合并框架，即先将数据分块，对每一块分别求和后，最后再将数据合并起来。
对于&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;distinct&lt;/code&gt;这类有状态的操作则是通过一个输入流产出对应的输出流，每一个输入数据
进入处理时还需要知道先前处理的历史，因此当流比较大或者无界时，有一些操作就会有问题，比如
将一个质数流进行倒序。（数学告诉我们，无穷多的质数无法倒序排序）&lt;/p&gt;

&lt;h3 id=&quot;数值流&quot;&gt;数值流&lt;/h3&gt;
&lt;p&gt;数值流是原始类型流的特化流，专门用于处理数值类型，如&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleStream&lt;/code&gt;、
&lt;code class=&quot;highlighter-rouge&quot;&gt;LongStream&lt;/code&gt;，使用数值流有两个原因，一是普通的对象流并没有提供数值操作才有的类似&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;
等方法，两个对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;并没有任何意义，虽然你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;Integer&amp;gt;&lt;/code&gt;的方式处理数值，
但是java的自动装箱机制会带来额外的开销，所以通过专门处理&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;型
的数值流，可以带来更高的效率。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将对象流通过mapToInt方法映射为一个数值流IntStream
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
int calories = intStream.sum();

// 数值流转换为对象流
Stream&amp;lt;Integer&amp;gt; stream = intStream.boxed();

// 数值型默认值，原生类型需使用对应的特化Optional版本，之所以需要OptionalInt
// 是因为流可能为空，所以不一定存在最大值，所以如果没有最大值时，我们可以显式提供一个。
OptionalInt maxCalories = intStream.max();
int max = maxCalories.orElse(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;数值流的范围&quot;&gt;数值流的范围&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;rangeClosed(m, n)&lt;/code&gt;方法生成从m到n（不包括n）范围的数值流。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IntStream evenNumbers = IntStream.rangeClosed(1, 100)
                                 .filter(n -&amp;gt; n % 2 == 0);
System.out.println(evenNumbers.count());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;构建流&quot;&gt;构建流&lt;/h3&gt;
&lt;p&gt;构建一个流有多种办法，通过从值序列、数组、文件来创建，甚至是生成函数来创建无限流。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;生成空流&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt; emptyStream = Stream.empty();&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;显式创建流&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;hello&quot;, &quot; world&quot;, &quot; my&quot;, &quot; friends&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由数组创建流&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;由文件生成流&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 读取data.txt文件并计算使用了多少种不同的单词。
Paths paths = Paths.get(&quot;path/data.txt&quot;);
long uniqueWords = Files.lines(paths, Charset.defaultCharset())
                        .flatMap(line -&amp;gt; Arrays.stream(line.split(&quot; &quot;)))
                        .distinct()
                        .count();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;通过函数生成无限流&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.iterate&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.generate&lt;/code&gt;方法可以生成无限流，对于无限流的使用，一般
会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;limit(n)&lt;/code&gt;来限制流的大小，避免出现无穷打印。
&lt;code class=&quot;highlighter-rouge&quot;&gt;public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f);&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;通过传入一个初始值seed和一元操作函数引用来迭代产生新的值，首先返回初始值seed，
然后通过初始值seed输入函数引用f，生成第二个值s1，接着通过s1输入f，得到第三个值s2，
以此类推。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface UnaryOperator&amp;lt;T&amp;gt; extends Function&amp;lt;T, T&amp;gt; {
}

public interface Function&amp;lt;T, R&amp;gt; {
    /**
     * Applies this function to the given argument.
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}

// 打印10个偶数
Stream.iterate(0, n -&amp;gt; n + 2)
      .limit(10)
      .forEach(System.out::println);

// 创建斐波那契数列
Stream.iterate(new int[]{0, 1}, t -&amp;gt; new int[]{t[1],t[0] + t[1]})
      .limit(10)
      .forEach(t -&amp;gt; System.out.println(&quot;(&quot; + t[0] + &quot;, &quot; + t[1] + &quot;)&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;方法类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt;方法是通过接收一个生产者&lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;的函数引用来生成
新的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; generate(Supplier&amp;lt;T&amp;gt; s);&lt;/code&gt;，通过方法引用，
我们可以内部维护一个状态，在每次生成数据之后可以更新该状态，从而实现有状态的供应源。
但是在并行流中使用有状态的流是不安全的，应当尽量避免。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Supplier&amp;lt;T&amp;gt; {
    /**
     * Gets a result.
     * @return a result
     */
    T get();
}

// 产生10个随机数
Stream.generate(Math::random)
      .limit(10)
      .forEach(System.out::println);

// 避免装箱操作，通过DoubleStream实现
DoubleStream.generate(Math::random)
            .limit(5)
            .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;收集&quot;&gt;收集&lt;/h3&gt;
&lt;p&gt;收集器是一个将数据按指定需求描述进行处理的函数式接口。通过收集器，你可以只通过描述数据
如何收集，而避免亲自实现如何收集。首先看一个根据货币类型分组交易的问题，使用原始的
迭代编码和使用收集器的简洁编码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过迭代的方式以Currency为键，对Transaction进行分组
private void groupImperatively() {
    Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transByCurrencies = new HashMap&amp;lt;&amp;gt;();
    for (Transaction transaction : transactions) {
        Currency currency = transaction.getCurrency();
        List&amp;lt;Transaction&amp;gt; transForCurrency = transByCurrencies.get(currency);
        if (transForCurrency == null) {
            transForCurrency = new ArrayList&amp;lt;&amp;gt;();
            transByCurrencies.put(currency, transForCurrency);
        }
        transForCurrency.add(transaction);
    }
    System.out.println(transByCurrencies);
}

// 通过java8收集器进行分组
private void groupFunctionally() {
    Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transByCurrencies = transactions.stream()
              .collect(Collectors.groupingBy(Transaction::getCurrency));
    System.out.println(transByCurrencies);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;从上面的对比看到使用函数式风格的收集器可以更好地维护代码，通过描述分组来完成分组的工作。
特别是当还有子分组的情况下，迭代式的实现子分组会加倍复杂化代码，而通过收集器，则只需要
增加一个子收集器即可。这样可以更好地复合和重用。而其中所有的收集器，都可以通过工厂类&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt;提供。&lt;/p&gt;

&lt;h4 id=&quot;归约-1&quot;&gt;归约&lt;/h4&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.counting&lt;/code&gt;方法获取菜单中有多少种菜&lt;code class=&quot;highlighter-rouge&quot;&gt;menu.stream().collect(Collectors.counting());&lt;/code&gt;
也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.count&lt;/code&gt;方法，以下面更为直接的形式实现&lt;code class=&quot;highlighter-rouge&quot;&gt;menu.stream().count();&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;最大最小值&quot;&gt;最大最小值&lt;/h4&gt;
&lt;p&gt;通过传入一个比较器，使用工厂类的&lt;code class=&quot;highlighter-rouge&quot;&gt;maxBy&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;minBy&lt;/code&gt;方法查找最高或最低热量的菜肴。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 获取最高热量的菜品
Comparator&amp;lt;Dish&amp;gt; comparator = Comparator.comparingInt(Dish::getCalories);
Optional&amp;lt;Dish&amp;gt; mostCaloriesDish = menu.stream()
                                      .collect(Collectors.maxBy(comparator));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;汇总&quot;&gt;汇总&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.summingInt&lt;/code&gt;方法返回一个”将对象转换为int的函数”的收集器，通过该收集器
来计算菜单中所有菜品的总热量。针对其他原生类型还提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;summingLong&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;summingDouble&lt;/code&gt;
方法。而汇总还包含了求平均数&lt;code class=&quot;highlighter-rouge&quot;&gt;averagingInt&lt;/code&gt;方法和对应&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;类型特异方法。
为了能够在一次计算中获取包含最大值、最小值、平均值等在内的所有值，&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt;还提供了
&lt;code class=&quot;highlighter-rouge&quot;&gt;summarizingInt&lt;/code&gt;方法，用于一次性获取对应规约汇总值。同提供&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;特异方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对菜单所有菜品总热量求和
int total = menu.stream().collect(Collectors.summingInt(Dish::getCalories));

// 平均热量
int average = menu.stream().collect(averagingInt(Dish::getCalories));

// 关于热量的统计值
IntSummaryStatistics statistics = menu.stream()
                        .collect(summarizingInt(Dish::getCalories));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;连接字符串&quot;&gt;连接字符串&lt;/h4&gt;
&lt;p&gt;连接字符串会将流中的所有元素通过指定的分隔符，串成一个字符串。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 根据逗号分隔所有菜品的菜名
String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));

// 如果Dish类中有一个toString方法来返回菜名，则无需通过菜品获取名称的映射
String shortMenu = menu.stream().collect(joining());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;广义的归约汇总&quot;&gt;广义的归约汇总&lt;/h4&gt;
&lt;p&gt;上述我们讨论的所有收集器，都是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.reducing&lt;/code&gt;工厂方法定义的归约过程的
特殊情况。&lt;code class=&quot;highlighter-rouge&quot;&gt;reducing&lt;/code&gt;方法是之前介绍的特殊收集的一般化。可以说，前面介绍的案例仅仅是
为了方便程序员开发而已，但是方便开发人员和可读性可是头等大事！所以我们可以通过一般
化方法计算菜单的总热量。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
int totalCalories = menu.stream()
              .collect(reducing(0, Dish::getCalories, Integer::sum)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;reducing共有三种重载方法，上面使用的是最基础的方法，首先给定一个起始值0，当流为空的
时候可作为默认值直接返回；第二个参数提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;，用于将流中的数据类型转换为需要
归约的目标数据类型，如将&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;类型转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;型；第三个参数则是用来进行归约的二元运算函数，
通过起始值0和流中第一个元素的转换类型，进行二元运算得到新值，然后将新值与流中的下一个
元素的转换值，继续进行归约运算，直到流中元素完成归约计算。下面是&lt;code class=&quot;highlighter-rouge&quot;&gt;reducing&lt;/code&gt;的定义。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * @param &amp;lt;T&amp;gt; the type of the input elements
 * @param &amp;lt;U&amp;gt; the type of the mapped values
 * @param identity the identity value for the reduction (also, the value
 *                 that is returned when there are no input elements)
 * @param mapper a mapping function to apply to each input value
 * @param op a BinaryOperator&amp;lt;U&amp;gt; used to reduce the mapped values
 * @return a Collector implementing the map-reduce operation
 *
 * @see #reducing(Object, BinaryOperator)
 * @see #reducing(BinaryOperator)
 */
public static &amp;lt;T, U&amp;gt; Collector&amp;lt;T, ?, U&amp;gt; reducing(U identity,
        Function&amp;lt;? super T, ? extends U&amp;gt; mapper, BinaryOperator&amp;lt;U&amp;gt; op);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重载的&lt;code class=&quot;highlighter-rouge&quot;&gt;reducing&lt;/code&gt;方法简化了输入流的类型和归约值的类型，即当两者相同时，无需再使用
映射函数，因此提供了仅有初始值和二元函数的方法，
&lt;code class=&quot;highlighter-rouge&quot;&gt;public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, T&amp;gt; reducing(T identity, BinaryOperator&amp;lt;T&amp;gt; op)&lt;/code&gt;
和仅有归约二元函数的方法，但是需要注意因为没有提供起始值，并且流可能为空，所以返回的
&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;类型是一个返回&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;的对象。
&lt;code class=&quot;highlighter-rouge&quot;&gt;public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Optional&amp;lt;T&amp;gt;&amp;gt; reducing(BinaryOperator&amp;lt;T&amp;gt; op)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;流的归约接口和收集器的归约方法&quot;&gt;流的归约接口和收集器的归约方法&lt;/h4&gt;
&lt;p&gt;对比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.reduce&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.reducing&lt;/code&gt;，我们可以发现许多类似之处，都存在三种
方法重载，并且使用模式基本一致。主要区别在于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.reduce&lt;/code&gt;方法用于直接在流中进行
归约，且其语义是不会改变容器，因此归约的方法均为无状态，从而可以进行高效地并行，而
&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt;是一个工具类，&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.reducing&lt;/code&gt;的目的是返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;接口，
通过该接口，我们可以结合&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.collect&lt;/code&gt;方法，对有状态的操作进行并行归约(使用分支/合并框架)。
因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;方法的语义则是改变容器，从而累积要输出的结果。&lt;/p&gt;

&lt;h4 id=&quot;收集框架的灵活性&quot;&gt;收集框架的灵活性&lt;/h4&gt;
&lt;p&gt;可以通过不同的方法执行相同的操作。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对菜单所有菜品总热量求和，使用多种方法
menu.stream().collect(summingInt(Dish::getCalories));
menu.stream().collect(reducing(0, Dish::getCalories, Integer::sum));
menu.stream().map(Dish::getCalories).reduce(Integer::sum).get();
menu.stream().mapToInt(Dish::getCalories).sum();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.counting&lt;/code&gt;方法，实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.reducing&lt;/code&gt;方法实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Long&amp;gt; counting() {
    return reducing(0L, e -&amp;gt; 1L, Long::sum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过上面的例子说明收集器在某种程度上比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;接口上直接提供的方法用起来更复杂，但好处
在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。但是这么多方案中，始终选择一个
最专业的方案是我们在实践中推荐的。最后一个热量求和方法最简洁，并且因为避免了自动
拆箱操作，性能也是最好的，所以应该使用该方法。&lt;/p&gt;

&lt;h3 id=&quot;分组&quot;&gt;分组&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.groupingBy&lt;/code&gt;工厂方法返回的收集器，可以轻松完成分组任务。如通过菜品
的类型进行分组并收集。我们可以看到最终结果是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;Dish.Type, List&amp;lt;Dish&amp;gt;&amp;gt;&lt;/code&gt;，
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish.Type&lt;/code&gt;为键，收集到对应的菜品保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Dish&amp;gt;&lt;/code&gt;中。从而通过描述分组简化了
分组的实现，可读性大大提高，开发者不需要自己编写和维护该&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;，同时因为分组使用了
分支/合并框架，可以支持高效的并行操作。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Map&amp;lt;Dish.Type, List&amp;lt;Dish&amp;gt;&amp;gt; groupDishesByType() {
    return menu.stream().collect(groupingBy(Dish::getType));
}

// 分组方法也有三种重载，下面给出最简单的一种。只需要提供一个分类函数，其中输入是流
中元素的值，输出则是分类依据的键，最终整个流将根据每个元素所属键的不同而分类并收集。
public static &amp;lt;T, K&amp;gt; Collector&amp;lt;T, ?, Map&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;
    groupingBy(Function&amp;lt;? super T, ? extends K&amp;gt; classifier);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;多级分组&quot;&gt;多级分组&lt;/h4&gt;
&lt;p&gt;在上例根据菜品类型分组的基础上，再根据菜品热量进行子分组，此时使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;groupingBy&lt;/code&gt;
方法需要第二个参数，即传递用于进行子分组的&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;收集器。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Map&amp;lt;Dish.Type, Map&amp;lt;CaloricLevel, List&amp;lt;Dish&amp;gt;&amp;gt;&amp;gt;
                                   groupDishedByTypeAndCaloricLevel() {
    return menu.stream().collect(
        // 先根据菜品类型分组
        groupingBy(Dish::getType,
            // 再根据菜品热量分为(0,400],(400,700],(700,)三种类别
            groupingBy((Dish dish) -&amp;gt; {
                if (dish.getCalories() &amp;lt;= 400) return CaloricLevel.DIET;
                else if (dish.getCalories() &amp;lt;= 700) return CaloricLevel.NORMAL;
                else return CaloricLevel.FAT;
            } )
        )
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而通过传递的收集器类型不同，除了进行子分组外，还能进行诸如计算、映射、收集等操作。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 统计各类菜品的数量。
menu.stream().collect(groupingBy(Dish::getType, counting()));

// 找出各类热量最高的菜品。注意返回Map&amp;lt;Dish.Type, Optional&amp;lt;Dish&amp;gt;&amp;gt;
menu.stream().collect(groupingBy(Dish::getType,
                                maxBy(comparingInt(Dish::getCalories))));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上述找出各类热量最高的菜品中，最终我们获得的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;Dish.Type, Optional&amp;lt;Dish&amp;gt;&amp;gt;&lt;/code&gt;
类型，而根据分组的定义可知，分组的菜品绝对不可能为空，因此，我们希望得到更为精确的类型。
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collectingAndThen&lt;/code&gt;方法以及传入的第二个转换函数来自动执行取值。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 找出各类热量最高的菜品。返回Map&amp;lt;Dish.Type, Dish&amp;gt;
menu.stream().collect(groupingBy(Dish::getType,
                collectingAndThen(maxBy(comparingInt(Dish::getCalories)),
                Optional::get));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;groupingBy&lt;/code&gt;联合其他类型的收集器，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.mapping&lt;/code&gt;方法生成，该
方法第一个参数对流中的元素做变换，另一个参数则将对象收集起来，通过变换，从而让接收特定
类型元素的收集器能够适应不同类型的对象。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T, U, A, R&amp;gt; Collector&amp;lt;T, ?, R&amp;gt; mapping(
                                Function&amp;lt;? super T, ? extends U&amp;gt; mapper,
                                Collector&amp;lt;? super U, A, R&amp;gt; downstream);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;比如我们想知道每一种菜品分别包含了哪一些热量级别，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mapping&lt;/code&gt;传递一个转换函数
以及&lt;code class=&quot;highlighter-rouge&quot;&gt;toSet()&lt;/code&gt;收集器来实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static Map&amp;lt;Dish.Type, Set&amp;lt;CaloricLevel&amp;gt;&amp;gt; caloricLevelsByType() {
    return menu.stream().collect(
            groupingBy(Dish::getType, mapping(
                    dish -&amp;gt; { if (dish.getCalories() &amp;lt;= 400)
                                    return CaloricLevel.DIET;
                    else if (dish.getCalories() &amp;lt;= 700)
                                    return CaloricLevel.NORMAL;
                    else return CaloricLevel.FAT; },
                    toSet() )));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;分区&quot;&gt;分区&lt;/h3&gt;
&lt;p&gt;分区是通过一个特定谓词（返回一个布尔值的函数）来将流中的元素分为满足条件的一类和不满足
条件的一类，因此可以理解为分组的一种特殊情况，包含仅包含&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;两种结果。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Collector&amp;lt;T, ?, Map&amp;lt;Boolean, List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;
                        partitioningBy(Predicate&amp;lt;? super T&amp;gt; predicate);

// 根据是否素食来分区菜品
private Map&amp;lt;Boolean, List&amp;lt;Dish&amp;gt;&amp;gt; partitionByVegeterian() {
    return menu.stream().collect(partitioningBy(Dish::isVegetarian));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;同样分区也支持多级分区，且可以进行分区和分组的多级组合，需要使用分区函数的重载版本，
用于在第二个参数中传递子收集器。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T, D, A&amp;gt; Collector&amp;lt;T, ?, Map&amp;lt;Boolean, D&amp;gt;&amp;gt; partitioningBy(
  Predicate&amp;lt;? super T&amp;gt; predicate, Collector&amp;lt;? super T, A, D&amp;gt; downstream);

 // 根据素食分区，并再进行菜品分类
private Map&amp;lt;Boolean, Map&amp;lt;Dish.Type, List&amp;lt;Dish&amp;gt;&amp;gt;&amp;gt; vegetarianDishesByType() {
    return menu.stream().collect(partitioningBy(Dish::isVegetarian,
                                            groupingBy(Dish::getType)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;收集器接口&quot;&gt;收集器接口&lt;/h3&gt;
&lt;p&gt;上面我们介绍的各种收集器，实际上都是通过收集器工具类&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors&lt;/code&gt;的静态工厂方法创建的。
而通过实现收集器接口&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;，我们可以自定义收集器，从而实现自定义的归约行为。先看一下
该接口的定义，T为流中元素的类型，A为累加器实现的类型，收集器通过该类型来实现状态的改变，
R为收集操作得到的结果类型（通常收集为集合，但也可以是其他类型如收集结果为一个最大值）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * @param &amp;lt;T&amp;gt; the type of input elements to the reduction operation
 * @param &amp;lt;A&amp;gt; the mutable accumulation type of the reduction operation (often
 *            hidden as an implementation detail)
 * @param &amp;lt;R&amp;gt; the result type of the reduction operation
 */
public interface Collector&amp;lt;T, A, R&amp;gt; {
    Supplier&amp;lt;A&amp;gt; supplier();         // 建立新的结果容器 A get();
    BiConsumer&amp;lt;A, T&amp;gt; accumulator(); // 将元素添加到结果容器 void accept(A a, T t);
    Function&amp;lt;A, R&amp;gt; finisher();      // 对结果容器应用最终转换 R apply(A a);
    BinaryOperator&amp;lt;A&amp;gt; combiner();   // 合并两个结果容器 A apply(A a1, A a2);
    Set&amp;lt;Characteristics&amp;gt; characteristics(); // 返回不可变的描述收集器行为的集合
}

// 收集器的使用，通过collect接口完成结果收集。
/*
 * @param &amp;lt;R&amp;gt; the type of the result
 * @param &amp;lt;A&amp;gt; the intermediate accumulation type of the Collector
 * @param collector the Collector describing the reduction
 * @return the result of the reduction
 * @see #collect(Supplier, BiConsumer, BiConsumer)
 * @see Collectors
 */
&amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super T, A, R&amp;gt; collector);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过前三个方法，即可满足对流进行顺序归约，增加&lt;code class=&quot;highlighter-rouge&quot;&gt;combiner&lt;/code&gt;方法后，则可以对流进行并行
归约，它会用到合并/分支框架和&lt;code class=&quot;highlighter-rouge&quot;&gt;Spliterator&lt;/code&gt;抽象(一种用于划分任务为更小部分的接口)，
通过对&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.toList&lt;/code&gt;工厂方法的模拟实现，我们可以更好地了解&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;接口中
各个方法的具体功能。对于将流中元素收集为列表的收集器实现类，我们可以进行如下定义。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ToListCollector&amp;lt;T&amp;gt; implement Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对于泛型T标识流中的元素，泛型A表示要收集的集合类型，因为是toList收集器，所以我们收集
为一个包含流中元素数据类型的列表，泛型R为收集器的最终结果，因为本次仅仅是将流中元素
进行收集，而并不是收集并转换为其他类型（比如将菜品对象流收集成菜名列表，此时输出的目标
类型并不是流中的元素，而是流中对象的菜名。三者泛型实际对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Dish&amp;gt;&lt;/code&gt;和
&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;的区别），因此输出结果也是流中元素数据类型的列表，即&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;supplier方法建立新的结果容器&quot;&gt;supplier方法：建立新的结果容器&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&lt;/code&gt;方法返回一个可以创建集合的函数，用于进行收集器集合的初始化，由于我们收集
结果为列表，所以应该返回一个列表对象的函数。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; supplier() {
    return () -&amp;gt; new ArrayList&amp;lt;T&amp;gt;();
}

// 也可以使用构造函数引用
public Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; supplier() {
    return ArrayList::new;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;accumulator方法将流中元素添加至结果容器&quot;&gt;accumulator方法：将流中元素添加至结果容器&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BiConsumer&lt;/code&gt;是一个双参数的消费者，即无返回值，结果容器的状态会在内部改变。该函数的
作用是将流中的元素添加至结果容器，即收集到列表容器中。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BiConsumer&amp;lt;T, U&amp;gt; {
    /**
     * Performs this operation on the given arguments.
     * @param t the first input argument
     * @param u the second input argument
     */
    void accept(T t, U u);
}

public BiConsumer&amp;lt;List&amp;lt;T&amp;gt;, T&amp;gt; accumulator() {
    return (list, item) -&amp;gt; list.add(item);
}

// 使用方法引用更为简洁
public BiConsumer&amp;lt;List&amp;lt;T&amp;gt;, T&amp;gt; accumulator() {
    return List::add;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;finisher方法对结果容器应用最终转换&quot;&gt;finisher方法：对结果容器应用最终转换&lt;/h4&gt;
&lt;p&gt;在遍历完流之后，我们得到了收集结果集，但这个结果并不一定是我们期望的结果，因此可以通过
该方法进行结果转换。对于toList收集器来说，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;supplier&lt;/code&gt;方法创建的列表已经是最终
我们期望的结果类型，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;finisher&lt;/code&gt;方法仅需返回&lt;code class=&quot;highlighter-rouge&quot;&gt;identity&lt;/code&gt;函数（一个返回输入参数的函数）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Function&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; finisher() {
    return Function.identity();
}

// 也可以直接返回输入对象
public Function&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; finisher() {
    return (list) -&amp;gt; list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;combiner方法合并两个结果容器&quot;&gt;combiner方法：合并两个结果容器&lt;/h4&gt;
&lt;p&gt;如果收集器需要支持并行，则可以通过实现combiner方法完成结果合并。结果之所以会出现多个，
是因为分支/合并框架会将流进行划分，并在多个线程执行。而执行完成后，需要通过combiner
方法将结果合并。对于两个列表的合并，可以将第二个列表的结果追加至第一个列表后。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public BinaryOperator&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; combiner() {
    return (list1, list2) -&amp;gt; {
        list1.addAll(list2);
        return list1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;characteristics方法描述收集器特性&quot;&gt;characteristics方法：描述收集器特性&lt;/h4&gt;
&lt;p&gt;该方法返回一个不可变的Characteristics集合，分别用于描述该收集器是否可以并行执行，是否
需要保持数据输入顺序，是否无需进行结果转换（本例实现的toList收集器即为无需结果转换），
通过这些特性描述，流框架会对收集器进行特性相关的优化。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Characteristics {
    CONCURRENT, UNORDERED, IDENTITY_FINISH
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;自定义收集器&quot;&gt;自定义收集器&lt;/h4&gt;
&lt;p&gt;对于无需对最终结果进行转换的收集器，可以通过收集器提供的另一个接口实现，而无需创建一个
&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;接口的子类，而该接口中的参数与&lt;code class=&quot;highlighter-rouge&quot;&gt;Collector&lt;/code&gt;接口中对应的方法功能类似，分别
提供了创建最终收集器结果集的&lt;code class=&quot;highlighter-rouge&quot;&gt;supplier&lt;/code&gt;，将流中每个元素应用到结果集的&lt;code class=&quot;highlighter-rouge&quot;&gt;accumulator&lt;/code&gt;，
用于支持并行、对两两结果集进行合并的&lt;code class=&quot;highlighter-rouge&quot;&gt;combiner&lt;/code&gt;方法，注意到由于不需要支持结果的转换，
所以&lt;code class=&quot;highlighter-rouge&quot;&gt;combiner&lt;/code&gt;返回的函数类型是一个双参数消费者，通过直接改变收集器状态来合并结果而
无返回参数。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * @param &amp;lt;R&amp;gt; type of the result
 * @param supplier a function that creates a new result container. For a
 *                 parallel execution, this function may be called
 *                 multiple times and must return a fresh value each time.
 * @param accumulator an associative, non-interfering, stateless function
 *        for incorporating an additional element into a result
 * @param combiner an associative, non-interfering, stateless function
 *        for combining two values, which must be compatible with the
 *        accumulator function
 * @return the result of the reduction
 */
&amp;lt;R&amp;gt; R collect(Supplier&amp;lt;R&amp;gt; supplier,
                  BiConsumer&amp;lt;R, ? super T&amp;gt; accumulator,
                  BiConsumer&amp;lt;R, R&amp;gt; combiner);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对于上例中实现的ToListCollector收集器，我们可以通过如下方法完成相同的操作。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; dishes = stream.collect(ArrayList::new, List::add, List::addAll);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;虽然下面这种编码方式更为简短，但可读性会弱一些，通过创建自定义收集器，我们可以更好地
复用相关代码和提高代码可读性。&lt;/p&gt;

&lt;h2 id=&quot;附录a-中间操作和终端操作表&quot;&gt;附录A 中间操作和终端操作表&lt;/h2&gt;
&lt;p&gt;| 操作      | 类型            | 返回类型           | 使用的类型/函数式接口 | 函数描述符    |
| ——– | ————— | —————– | —————— | ———— |
| filter   | 中间             |  Stream&lt;T&gt;        |  Predicate&lt;T&gt;      | T -&amp;gt; boolean |
| distinct | 中间（有状态-无界）|  Stream&lt;T&gt;        |                    |              |&lt;/T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/p&gt;

&lt;h2 id=&quot;附录b-收集器工具类方法表&quot;&gt;附录B 收集器工具类方法表&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;toList&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;toSet&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;toCollection&lt;/code&gt;&lt;/p&gt;</content><author><name>grimkeke</name></author><summary type="html">什么是流 流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询 的语句，而不是亲自实现一个查询功能）。对比面向集合，亲自来实现集合操作，通过流， 开发者可以关注于实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询菜品列表 中热量小于400的菜品名称，并且根据菜品热量排序。java7的方法为面向集合、根据语义实现， 即首先遍历所有的菜品，找出热量小于400的菜品并添加到临时列表，根据热量排序，然后再创建 一个列表用于提取菜品的名称。 ``` public List getLowCaloricDishesNamesInJava7(List dishes){ List lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for(Dish d: dishes){ if(d.getCalories() &amp;lt; 400){ lowCaloricDishes.add(d); } }</summary></entry><entry><title type="html">Hello World To Java8</title><link href="http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8.html" rel="alternate" type="text/html" title="Hello World To Java8" /><published>2018-01-12T11:57:44+08:00</published><updated>2018-01-12T11:57:44+08:00</updated><id>http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8</id><content type="html" xml:base="http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8.html">&lt;h2 id=&quot;为什么用java8&quot;&gt;为什么用java8&lt;/h2&gt;
&lt;p&gt;在了解和学习了java8之后，我发现java8带来的优势和所提升的效率，比学习它的成本要多得多，
所以在此向大家推荐使用java8的新特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;通过方法参数传递代码块的能力以及使用lambda匿名函数替代实现匿名类。&lt;/li&gt;
  &lt;li&gt;新的流（Stream）API，提供了一种高层次集合操作方法，并带来了随手可得的并行能力。&lt;/li&gt;
  &lt;li&gt;为接口提供默认方法的能力，为扩展接口带来了福音。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;传递代码的能力&quot;&gt;传递代码的能力&lt;/h2&gt;
&lt;p&gt;java8之前的方法参数只能传递对象，而java8允许我们将方法的引用作为参数传递给方法。
如&lt;code class=&quot;highlighter-rouge&quot;&gt;findApples(apples, Apple::isRedColor)&lt;/code&gt;，我们传递了&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;类的方法，让
&lt;code class=&quot;highlighter-rouge&quot;&gt;findApples&lt;/code&gt;方法根据&lt;code class=&quot;highlighter-rouge&quot;&gt;isRedColor&lt;/code&gt;方法筛选需要的苹果。下面介绍一个完整的演变过程。
如果从一堆苹果中找出大的苹果，你之前可能会写如下代码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Apple&amp;gt; findBigApples(List&amp;lt;Apple&amp;gt; apples) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (apple.getWeight() &amp;gt; 200) {
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;后来可能又有需求是需要找出红苹果，于是可能会新增一个找红苹果的方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Apple&amp;gt; findRedApples(List&amp;lt;Apple&amp;gt; apples) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (apple.getColor() == Color.RED) {
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;findBigApples&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;findRedApples&lt;/code&gt;的唯一区别仅仅是判断苹果的条件，所以你可能会通过一个
接口，将筛选方法作为策略传入。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 判断策略
public interface Predicate&amp;lt;T&amp;gt; {
    boolean test(T t);
}

// 通过指定的策略查找苹果
public List&amp;lt;Apple&amp;gt; findApples(List&amp;lt;Apple&amp;gt; apples, Predicate&amp;lt;Apple&amp;gt; p) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (p.test(apple)) {  // 如果苹果满足p所代表的筛选方法
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而如果使用了传递代码的能力，你可以将筛选大苹果的使用方法优化为如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, Apple::isBigEnough);

// 其中Apple::isBigEnough为Apple对象的方法引用，isBigEnough方法为判断是否是大苹果的方法
public boolean isBigEnough() {
    return this.getWeight() &amp;gt; 200;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而找出红苹果的方法可以优化为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, Apple::isRedColor);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而对于既要大苹果又要红苹果的情形，你可能会写一个仅用一次的方法，针对这种情况，可以通过
lambda表达式进行优化。&lt;/p&gt;
&lt;h3 id=&quot;使用lambda匿名函数&quot;&gt;使用lambda匿名函数&lt;/h3&gt;
&lt;p&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;public int add(int x, int y) {return x + y;}&lt;/code&gt;可等效于lambda匿名函数
&lt;code class=&quot;highlighter-rouge&quot;&gt;(int x, int y) -&amp;gt; {return x + y;}&lt;/code&gt;，当代码块只有一行时，可简写为&lt;code class=&quot;highlighter-rouge&quot;&gt;(x, y) -&amp;gt; x + y&lt;/code&gt;。
所以找出又大又红的苹果可以通过传入lambda表达式实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, (Apple apple) -&amp;gt; {
    return apple.isBigEnough() &amp;amp;&amp;amp; apple.isRedColor()
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果lambda仅有一行表达式，可以省略return语句和两端花括号，同时Apple参数类型也可以省略，
jvm会根据上下文分析正确的参数类型。所以简化版的表达式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, (apple) -&amp;gt; apple.isBigEnough() &amp;amp;&amp;amp; apple.isRedColor());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有高手会表示之前的java也能通过策略模式向方法中传递代码，比如通过匿名类对接口的实现来传递
不同的代码块。但是相比冗长地定义接口实现，通过直接传递方法引用和lambda表达式能更加
简化代码并且提供清晰的可读性。对比一下我们以前通过匿名类实现的找出大苹果的方式，体会一下
可读性。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, new Predicate&amp;lt;Apple&amp;gt; {
    @Override
    public boolean test(Apple apple) {
        return apple.isBigEnough();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;引入lambda，并不只是一个语法糖，而是通过java7中新的&lt;a href=&quot;http://www.infoq.com/cn/articles/Invokedynamic-Javas-secret-weapon&quot;&gt;invokedynamic&lt;/a&gt;字节码，在运行时
确定执行的方法，这样可以将Groovy、Scala这类脚本语言进行粘合。&lt;/p&gt;

&lt;h2 id=&quot;流api&quot;&gt;流API&lt;/h2&gt;
&lt;p&gt;流提供了一种抽象的集合操作，通过类比SQL提供的数据操作指令，流提供了在java环境中的
一套编程模式，继续找苹果的例子，通过流，我们可以免去编写显示的循环操作，下面通流API，
使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;的筛选大苹果的方法，从所有苹果中筛选出大苹果并返回。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import static java.util.stream.Collections.toList;
List&amp;lt;Apple&amp;gt; bigApples = apples.stream()
                              .filter((apple) -&amp;gt; apple.isBigEnough())
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面的示例也可通过传递方法引用表示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Apple&amp;gt; bigApples = apples.stream()
                              .filter(Apple::isBigEnough)
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意其中并没有使用for循环，循环由流隐式内部实现了，由此带来的好处就是可以非常简单地
获得多处理机上的并行能力，在此之前java并不能主动利用多核，通过多线程提高效率。而使用
并行流，我们能轻松获得类似流水线的并行处理能力。而其他代码完全无需变更。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Apple&amp;gt; bigApples = apples.parallelStream()
                              .filter(Apple::isBigEnough)
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;接口默认方法&quot;&gt;接口默认方法&lt;/h2&gt;
&lt;p&gt;接口通过&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;关键字可以支持接口中实现方法体，如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Sample {
    String getName();

    default void doSomething() {
        System.out.println(&quot;print default method.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过接口默认方法，当我们需要对接口进行变更时，可以避免让接口的所有实现类以及子类进行修改
和重新编译。接口实现类和其子类可以直接使用接口默认方法。&lt;/p&gt;

&lt;h2 id=&quot;了解更多&quot;&gt;了解更多&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26772632/&quot;&gt;《java8实战》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>grimkeke</name></author><summary type="html">为什么用java8 在了解和学习了java8之后，我发现java8带来的优势和所提升的效率，比学习它的成本要多得多， 所以在此向大家推荐使用java8的新特性： 通过方法参数传递代码块的能力以及使用lambda匿名函数替代实现匿名类。 新的流（Stream）API，提供了一种高层次集合操作方法，并带来了随手可得的并行能力。 为接口提供默认方法的能力，为扩展接口带来了福音。</summary></entry><entry><title type="html">How To Change Default JRE In IntelliJ Idea</title><link href="http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea.html" rel="alternate" type="text/html" title="How To Change Default JRE In IntelliJ Idea" /><published>2017-05-09T12:51:44+08:00</published><updated>2017-05-09T12:51:44+08:00</updated><id>http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea</id><content type="html" xml:base="http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea.html">&lt;p&gt;Intellij IDEA 默认情况下，使用的jdk的版本是1.6，当第一次启动IDEA的时候，如果系统中未安装jdk，则系统会自动到苹果官网下载jdk安装文件。如果你的系 统已经安装了jdk1.7或是更高的版本，同样首次打开IDEA的时候要求你安装苹果官网jdk1.6。&lt;/p&gt;

&lt;p&gt;为了免去多余的jdk安装，解决办法如下：&lt;/p&gt;

&lt;p&gt;到/Applications下找到IntelliJ IDEA 13，右键－&amp;gt;显示包内容－&amp;gt;Contents-&amp;gt;Info.plist，利用文本编辑器或是默认的xcode打开该文件，找到下列代码&lt;/p&gt;

&lt;key&gt;JVMVersion&lt;/key&gt;
&lt;string&gt;1.6*&lt;/string&gt;

&lt;p&gt;将&lt;string&gt;1.6*&lt;/string&gt;改为&lt;string&gt;1.7*&lt;/string&gt;保存。&lt;/p&gt;

&lt;p&gt;此时idea使用的jdk就是1.7及以上的版本了。&lt;/p&gt;</content><author><name>grimkeke</name></author><summary type="html">Intellij IDEA 默认情况下，使用的jdk的版本是1.6，当第一次启动IDEA的时候，如果系统中未安装jdk，则系统会自动到苹果官网下载jdk安装文件。如果你的系 统已经安装了jdk1.7或是更高的版本，同样首次打开IDEA的时候要求你安装苹果官网jdk1.6。</summary></entry><entry><title type="html">如何创建自己的github.io站点</title><link href="http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site.html" rel="alternate" type="text/html" title="如何创建自己的github.io站点" /><published>2017-03-26T16:59:44+08:00</published><updated>2017-03-26T16:59:44+08:00</updated><id>http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site</id><content type="html" xml:base="http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site.html">&lt;p&gt;github提供了一种&lt;a href=&quot;https://pages.github.com/&quot;&gt;主页服务&lt;/a&gt;，当用户在github创建了一个(用户名.github.io)格式命名的项目后，
github会为其生成静态站点。 比如我的用户名为grimkeke，那么当我创建了grimkeke.github.io项目，并提交一个文本文件（如html）后，
访问&lt;a href=&quot;https://grimkeke.github.io&quot;&gt;https://grimkeke.github.io&lt;/a&gt;即可访问刚才提交的文件，需要注意项目名称必须为自身用户名，否则即使上传了文件，浏览器也会报错404.&lt;/p&gt;

&lt;p&gt;对于正式编写blog，推荐使用&lt;a href=&quot;https://jekyllrb.com/docs/quickstart/&quot;&gt;Jekyll&lt;/a&gt;，它支持markdown编写笔记，通过命令生成静态文件，并且与github完全打通，
通过jekyll创建的项目，直接上传至github后即为最终站点效果。&lt;/p&gt;

&lt;h4 id=&quot;如何使用jekyll&quot;&gt;如何使用jekyll&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Install Jekyll and Bundler gems through RubyGems
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll bundler&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create a new Jekyll site at ./myblog
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new myblog&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Change into your new directory
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd myblog&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build the site on the preview server
&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle exec jekyll serve&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now browse to http://localhost:4000&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>grimkeke</name></author><summary type="html">github提供了一种主页服务，当用户在github创建了一个(用户名.github.io)格式命名的项目后， github会为其生成静态站点。 比如我的用户名为grimkeke，那么当我创建了grimkeke.github.io项目，并提交一个文本文件（如html）后， 访问https://grimkeke.github.io即可访问刚才提交的文件，需要注意项目名称必须为自身用户名，否则即使上传了文件，浏览器也会报错404.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-03-26T13:59:44+08:00</published><updated>2017-03-26T13:59:44+08:00</updated><id>http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>grimkeke</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>