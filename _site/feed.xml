<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.3">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2018-02-13T15:47:59+08:00</updated><id>http://0.0.0.0:4000/</id><title type="html">小笔记</title><subtitle>simple site to write note.
</subtitle><author><name>grimkeke</name></author><entry><title type="html">Stream读书笔记</title><link href="http://0.0.0.0:4000/java8/2018/01/14/know-stream-api.html" rel="alternate" type="text/html" title="Stream读书笔记" /><published>2018-01-14T11:57:44+08:00</published><updated>2018-01-14T11:57:44+08:00</updated><id>http://0.0.0.0:4000/java8/2018/01/14/know-stream-api</id><content type="html" xml:base="http://0.0.0.0:4000/java8/2018/01/14/know-stream-api.html">&lt;h2 id=&quot;什么是流&quot;&gt;什么是流&lt;/h2&gt;
&lt;p&gt;流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询
的语句，而不是亲自实现一个查询功能）。对比之前面向集合，亲自来实现集合操作，通过流，
开发者可以关注与实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询Dish列表
中卡路里小于400的菜品名称，并且根据菜品卡路里排序。java7的方法即为根据语义进行实现，
即首先遍历所有的菜品，找出小于400卡路里的菜品添加到临时列表，进行排序，然后再创建一个
列表用于提取菜品的名称。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava7(List&amp;lt;Dish&amp;gt; dishes){
    List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;();
    for(Dish d: dishes){
        if(d.getCalories() &amp;lt; 400){
            lowCaloricDishes.add(d);
        }
    }

    Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() {
        public int compare(Dish d1, Dish d2){
            return Integer.compare(d1.getCalories(), d2.getCalories());
        }
    });

    List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;();
    for(Dish d: lowCaloricDishes){
        lowCaloricDishesName.add(d.getName());
    }
    return lowCaloricDishesName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而java8的流操作就很直观，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.stream()&lt;/code&gt;方法，将菜品列表
转换为菜品流，接着通过&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;过滤，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sorted&lt;/code&gt;进行排序，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;将菜品列表映射
为名称列表，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;收集保存为List。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava8(List&amp;lt;Dish&amp;gt; dishes){
    return dishes.stream()
            .filter(d -&amp;gt; d.getCalories() &amp;lt; 400)
            .sorted(Comparator.comparing(Dish::getCalories))
            .map(Dish::getName)
            .collect(Collectors.toList());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而将流操作转变为并行操作也非常简单，只需将&lt;code class=&quot;highlighter-rouge&quot;&gt;.stream()&lt;/code&gt;方法修改为&lt;code class=&quot;highlighter-rouge&quot;&gt;.parallelStream()&lt;/code&gt;
方法即可。流默认会根据当前运行机器的内核数来进行并行执行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; getLowCaloricDishesNamesInJava8(List&amp;lt;Dish&amp;gt; dishes){
    return dishes.parallelStream()
            .filter(d -&amp;gt; d.getCalories() &amp;lt; 400)
            .sorted(Comparator.comparing(Dish::getCalories))
            .map(Dish::getName)
            .collect(Collectors.toList());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;除了生命式的表述数据操作方式之外，流的编写模式是链式的，即通过一系列方法组合成操作
流水线。而在流的内部，每个处理节点的操作也像流水线一样并行处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           lamdba             lambda             lambda
             +                   +                  +
             |                   |                  |
menu    +----v-----+       +-----v----+       +-----v----+      +---------+
+-------&amp;gt;  filter  +-------&amp;gt;  sorted  +-------&amp;gt;   map    +------&amp;gt; collect |
        +----------+       +----------+       +----------+      +---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;即流有如下三个特点：声明式、可复合（链式）、可并行。&lt;/p&gt;
&lt;h2 id=&quot;流与集合的理解&quot;&gt;流与集合的理解&lt;/h2&gt;
&lt;p&gt;集合可以理解为空间上的一组序列，首先集合中的元素必须都存在才能产生集合，如我们无法创建
一个偶数的集合，因为偶数是无穷的，因此集合是无穷的，空间上无法确定集合大小。而流则可以
理解为时间上的一组序列，流中的元素不必全部产生后才可使用，因此，流有按需生产、延迟生产
的特点，我们可以很轻易地创建一个包含所有偶数的流，只不过这个流中的元素永远也输出不完。&lt;/p&gt;
&lt;h3 id=&quot;外部迭代和内部迭代&quot;&gt;外部迭代和内部迭代&lt;/h3&gt;
&lt;p&gt;集合中的元素是确定的，并且我们需要自行创建迭代来遍历集合中的所有元素；而流中的元素则
是由内部迭代完成的，迭代交给流来进行有很多好处，首先带来了声明式的简洁，且因为迭代在
内部进行，流的实现者可以为我们提供了迭代优化和并行优化（具体通过java7提供的fork-join
框架实现）&lt;/p&gt;
&lt;h3 id=&quot;流的操作&quot;&gt;流的操作&lt;/h3&gt;
&lt;p&gt;流分为中间操作和终端操作两种操作类型。中间操作并不真正操作流中的元素，而是建设起操作流
的流水线，这种流的延迟特性带来了&lt;code class=&quot;highlighter-rouge&quot;&gt;循环合并&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;短路&lt;/code&gt;等优化技巧的用武之地。而终端操作则会
从流水线生成结果。这个结果是任何不是流的值，比如void，List，int等。并且流只能够遍历
一次，所以无法一次链式处理的流操作，需要再次打开流，进行第二次遍历处理。在上述例子中，
filter、sorted、map为中间操作，collect为终端操作。&lt;/p&gt;
&lt;h2 id=&quot;使用流&quot;&gt;使用流&lt;/h2&gt;
&lt;p&gt;流提供了许多操作，能够给你快速完成复杂的数据处理，如筛选、切片、映射、查找、匹配和规约。&lt;/p&gt;
&lt;h3 id=&quot;筛选&quot;&gt;筛选&lt;/h3&gt;
&lt;p&gt;通过谓词筛选，&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;接口&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate)&lt;/code&gt;需要
提供一个谓词，而谓词是一个返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的接口，用于根据指定元素t进行条件判断&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Predicate&amp;lt;T&amp;gt; {
    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在本例中，我们通过传入&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象的方法引用&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish::isVegetarian&lt;/code&gt;来告诉菜品流，我们要
过滤出所有的素食菜品&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream()
                                .filter(Dish::isVegetarian)
                                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象中判断是否是素食的方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isVegetarian() {
        return vegetarian;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而根据lambda表达式，过滤方法也可以按如下形式表达&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream()
                                .filter(dish -&amp;gt; dish.isVegetarian())
                                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;筛选各异的元素&quot;&gt;筛选各异的元素&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;distinct()&lt;/code&gt;方法，我们可以筛选出不重复的元素&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
       .filter(i -&amp;gt; i % 2 == 0)
       .distinct()
       .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;截短流&quot;&gt;截短流&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;limit(3)&lt;/code&gt;将流的输出限制为3个，在流的内部实现中，会采用一种叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;短路&lt;/code&gt;的优化，即
无需完整过滤完整个流，只要&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;方法过滤出3个菜品，即马上停止流的内部遍历，通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;collect()&lt;/code&gt;方法返回列表。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; dishesLimit3 = menu.stream()
                .filter(d -&amp;gt; d.getCalories() &amp;gt; 300)
                .limit(3)
                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;跳过元素&quot;&gt;跳过元素&lt;/h3&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;skip(2)&lt;/code&gt;方法，返回一个丢弃了前两个元素的流。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Dish&amp;gt; dishesSkip2 = menu.stream()
                .filter(d -&amp;gt; d.getCalories() &amp;gt; 300)
                .skip(2)
                .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;映射&quot;&gt;映射&lt;/h3&gt;
&lt;p&gt;映射类似于SQL里筛选出一张表中的某一列数据，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;方法，我们可以将流
中的元素结合映射为另一种类型的集合，比如从菜品流&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;Dish&amp;gt;&lt;/code&gt;选出所有菜品的名称&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;。
&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;接口&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper)&lt;/code&gt;需要
传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;类型的函数式接口，这个接口的作用是把传入的参数从一种类型转换为另一种类型，
就菜品转换而言，流内部的循环会通过这个接口把单个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;元素转变为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;元素，然后
通过内部迭代器收集对象，最终通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt;输出为列表或者做其他处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Function&amp;lt;T, R&amp;gt; {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在本例中，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象映射为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象，即获取菜品的名称，最后
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Collectors.toList()&lt;/code&gt;方法采集输出为字符串列表。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; dishNames = menu.stream()
                             .map(Dish::getName)
                             .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dish&lt;/code&gt;对象中获取菜品名称的方法如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public String getName() {
        return name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面的例子展示了计算数组中每个单词的长度，通过方法引用&lt;code class=&quot;highlighter-rouge&quot;&gt;String::length&lt;/code&gt;获得每个单词
的长度，返回类型&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;通过java的自动装箱操作转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;类型（自动装箱操作有额外
操作成本，需要进行关注，后续会介绍java8提供的几个原生Stream类型用于提高性能），&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);
List&amp;lt;Integer&amp;gt; wordLengths = words.stream()
                                 .map(String::length)
                                 .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;流的扁平化&quot;&gt;流的扁平化&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&lt;/code&gt;
需要传入一个输出转换结果为流的函数方法。即&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;首先将输入流中的每个元素，
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;接口转换为对应的流，然后再将所有得到的流连接起来成为一个流。
为了输出单词列表中所有出现的不同字母，我们首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays.stream()&lt;/code&gt;方法将输入字符串
转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;，然后每个单词转换的流进行数据整合，归集为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;
流，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;distinct()&lt;/code&gt;方法筛选流中所有不重复的字母。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;words.stream()
     .flatMap((String line) -&amp;gt; Arrays.stream(line.split(&quot;&quot;)))
     .distinct()
     .forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;匹配&quot;&gt;匹配&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;检查谓词是否至少匹配一个元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .anyMatch(Dish::isVegetarian);  // 菜单中是否有一个素菜
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;检查谓词匹配所有元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .allMatch(d -&amp;gt; d.getCalories() &amp;lt; 1000);  // 所有菜品卡路里是否小于1000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;检查谓词对所有元素均不匹配：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;menu.stream()
  .noneMatch(d -&amp;gt; d.getCalories() &amp;gt;= 1000); // 所有菜品卡路里是否不大于1000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三个查找方法均使用到了短路优化，即在满足条件时，无需完整遍历流中所有元素，即可返回结果。&lt;/p&gt;
&lt;h3 id=&quot;查找元素&quot;&gt;查找元素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;查找任意元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt; findAny();&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Dish&amp;gt; dish = menu.stream()
          .filter(Dish::isVegetarian).findAny();  // 找出菜单任意一个素菜
dish.ifPresent(d -&amp;gt; System.out.println(d.getName())); // 如果有素菜则打印菜名
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查找第一个元素：&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt; findFirst();&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Dish&amp;gt; dish = menu.stream()
          .filter(Dish::isVegetarian).findFirst();  // 找出菜单第一个素菜
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查找元素返回的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;类型，用于表示对象是否存在，通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer)&lt;/code&gt;方法可以传入一个消费者，当对象存在时，执行消费者的消费动作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Consumer&amp;lt;T&amp;gt; {
    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;归约&quot;&gt;归约&lt;/h3&gt;
&lt;p&gt;归约用来将一系列元素折叠成一个元素，比如对1至100的数字求和，通过归约操作，我们可以不断
对累积值和流中的数字使用加法，从而完成所有数字的累加，最终累积值即为所有元素之和。归约
操作通过&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt;方法实现。我们先来看一下它的用法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(3,4,5,1,2);
int sum = numbers.stream().reduce(0, (a, b) -&amp;gt; a + b);

// 通过Integer提供的求和静态方法sum完成累加
int sum2 = numbers.stream().reduce(0, Integer::sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该方法有如下两种重载：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;提供初始值，以及一个二元操作的方法引用，上面例子使用的是该用法，通过提供初始值以及
一个函数引用，我们向流提供一种累加的方法，即我们需要一个整数，初始值为0，
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;(a, b) -&amp;gt; a + b&lt;/code&gt;方法 （即&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer::sum&lt;/code&gt;）不断与流中的元素进行归约计算，
最终得到累加和的输出。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;仅提供二元操作的方法引用，当流为空时，可能会返回空结果，因此方法签名的返回值为
一个可选的&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时，我们也可以通过归约来求出流中的最大值最小值，因为求出流中的最大值最小值也是分别
两两比较流内的数字。下面例子可以计算如何求流的最大值，当流为空时，最大值为0。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int max = numbers.stream().reduce(0, (a, b) -&amp;gt; Integer.max(a, b));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这不一定是你期望的结果，因此可以采用&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt;方法的单参数重载方法。并根据流非空的情况
进行相应处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional&amp;lt;Integer&amp;gt; min = numbers.stream().reduce(Integer::min);
min.ifPresent(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于流的操作，诸如map或者filter等操作会从输入中获取每一个元素进行处理，并且得到0个
或者1个结果，这些操作一般是无状态的，因此可以很容易地并行化。而对于reduce、sum、max
这类操作则需要内部维护一个状态来进行累计结果，因此被称为有状态，所以内部实现的并行策略
会完全不一样，会使用分支/合并框架，即先讲数据分块，分块求和后，最后再将数据合并起来。
对于sort或者distinct这类有状态的操作是通过一个输入流产出对应的输出流，每一个输入数据
进入处理时还需要知道先前处理的历史，因此当流比较大或者无界时，有一些操作就会有问题，比如
将一个质数流进行倒序（数学告诉我们，无穷多的质数无法倒序排序）&lt;/p&gt;
&lt;h3 id=&quot;数值流&quot;&gt;数值流&lt;/h3&gt;
&lt;p&gt;数值流是原始类型流的特化流，专门用于处理数值类型，如&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;DoubleStream&lt;/code&gt;、
&lt;code class=&quot;highlighter-rouge&quot;&gt;LongStream&lt;/code&gt;，使用数值流有两个原因，一是通用的流并没有提供数值操作才有的类似sum等方法，
两个对象的sum并没有任何意义，虽然你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;Integer&amp;gt;&lt;/code&gt;的方式处理数值，但是
java的自动装箱机制会带来额外的开销，所以通过专门处理int、double和long型的数值流，
可以带来更高的效率。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
int calories = intStream.sum();

// 数值流转换为对象流
Stream&amp;lt;Integer&amp;gt; stream = intStream.boxed();

// 数值型默认值，原生类型需使用对应的特异化Optional版本，之所以是需要OptionalInt
// 是因为流可能为空，所以不一定存在最大值，所以如果没有最大值时，我们可以显式提供一个。
OptionalInt maxCalories = intStream.max();
int max = maxCalories.orElse(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;数值流的范围&quot;&gt;数值流的范围&lt;/h4&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;rangeClosed(m, n)&lt;/code&gt;方法生成从m到n（不包括n）范围的数值流。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IntStream evenNumbers = IntStream.rangeClosed(1, 100)
                                 .filter(n -&amp;gt; n % 2 == 0);
System.out.println(evenNumbers.count());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;构建流&quot;&gt;构建流&lt;/h3&gt;
&lt;p&gt;构建一个流有多种办法，通过从值序列、数组、文件来创建，甚至是生成函数来创建无限流。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;生成空流
&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt; emptyStream = Stream.empty();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;显示创建流
&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;hello&quot;, &quot; world&quot;, &quot; my&quot;, &quot; friends&quot;);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;由数组创建流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;由文件生成流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 读取data.txt文件并计算使用了多少种不同的单词。
Paths paths = Paths.get(&quot;path/data.txt&quot;);
long uniqueWords = Files.lines(paths, Charset.defaultCharset())
                      .flatMap(line -&amp;gt; Arrays.stream(line.split(&quot; &quot;)))
                      .distinct()
                      .count();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;通过函数生成无限流
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.iterate&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Stream.generate&lt;/code&gt;方法可以生成无限流，对于无限流的使用，一般
会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;limit(n)&lt;/code&gt;来限制流的大小，避免出现无穷打印。
&lt;code class=&quot;highlighter-rouge&quot;&gt;public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f);&lt;/code&gt;
iterate通过传入一个初始值seed和一元操作函数引用来迭代产生新的值，首先返回初始值seed，
然后通过初始值seed输入函数引用f，生成第二个值s1，接着通过s1输入f，得到第三个值s2，
以此类推。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 打印10个偶数
Stream.iterate(0, n -&amp;gt; n + 2)
    .limit(10)
    .forEach(System.out::println);
// 创建斐波那契数列
Stream.iterate(new int[]{0, 1}, t -&amp;gt; new int[]{t[1],t[0] + t[1]})
    .limit(10)
    .forEach(t -&amp;gt; System.out.println(&quot;(&quot; + t[0] + &quot;, &quot; + t[1] + &quot;)&quot;));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;方法类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt;方法是通过接收一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;的函数引用来生成
新的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; generate(Supplier&amp;lt;T&amp;gt; s);&lt;/code&gt;，通过方法引用，
我们可以内部维护一个状态，在每次生成数据之后可以更新该状态，从而实现有状态的供应源。
但是在并行流中使用有状态的流是不安全的，应答尽量避免。
```
// 产生10个随机数
Stream.generate(Math::random)
    .limit(10)
    .forEach(System.out::println);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 避免装箱操作，通过DoubleStream实现
DoubleStream.generate(Math::random)
            .limit(5)
            .forEach(System.out::println);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### 收集
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
                  BiConsumer&amp;lt;R, ? super T&amp;gt; accumulator,
                  BiConsumer&amp;lt;R, R&amp;gt; combiner);
```

### 附录A 中间操作和终端操作表
| 操作      | 类型            | 返回类型           | 使用的类型/函数式接口 | 函数描述符    |
| -------- | --------------- | ----------------- | ------------------ | ------------ |
| filter   | 中间             | `Stream&lt;T&gt;`       | `Predicate&lt;T&gt;`     | T -&amp;gt; boolean |
| distinct | 中间（有状态-无界）| `Stream&lt;T&gt;`       |                    |              |
&lt;/T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/R&gt;&lt;/R&gt;</content><author><name>grimkeke</name></author><summary type="html">什么是流 流（Stream）是一组Java API，通过声明式的方式处理数据集合（类似于SQL，通过编写查询 的语句，而不是亲自实现一个查询功能）。对比之前面向集合，亲自来实现集合操作，通过流， 开发者可以关注与实现的目的，而非实现操作本身。对比如下两段功能一样的代码，查询Dish列表 中卡路里小于400的菜品名称，并且根据菜品卡路里排序。java7的方法即为根据语义进行实现， 即首先遍历所有的菜品，找出小于400卡路里的菜品添加到临时列表，进行排序，然后再创建一个 列表用于提取菜品的名称。 ``` public List getLowCaloricDishesNamesInJava7(List dishes){ List lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for(Dish d: dishes){ if(d.getCalories() &amp;lt; 400){ lowCaloricDishes.add(d); } }</summary></entry><entry><title type="html">Hello World To Java8</title><link href="http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8.html" rel="alternate" type="text/html" title="Hello World To Java8" /><published>2018-01-12T11:57:44+08:00</published><updated>2018-01-12T11:57:44+08:00</updated><id>http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8</id><content type="html" xml:base="http://0.0.0.0:4000/java8/2018/01/12/hello-world-to-java8.html">&lt;h2 id=&quot;为什么用java8&quot;&gt;为什么用java8&lt;/h2&gt;
&lt;p&gt;在了解和学习了java8之后，我发现java8带来的优势和所提升的效率，比学习它的成本要多得多，
所以在此向大家推荐使用java8的新特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;通过方法参数传递代码块的能力以及使用lambda匿名函数替代实现匿名类。&lt;/li&gt;
  &lt;li&gt;新的流（Stream）API，提供了一种高层次集合操作方法，并带来了随手可得的并行能力。&lt;/li&gt;
  &lt;li&gt;为接口提供默认方法的能力，为扩展接口带来了福音。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;传递代码的能力&quot;&gt;传递代码的能力&lt;/h2&gt;
&lt;p&gt;java8之前的方法参数只能传递对象，而java8允许我们将方法的引用作为参数传递给方法。
如&lt;code class=&quot;highlighter-rouge&quot;&gt;findApples(apples, Apple::isRedColor)&lt;/code&gt;，我们传递了&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;类的方法，让
&lt;code class=&quot;highlighter-rouge&quot;&gt;findApples&lt;/code&gt;方法根据&lt;code class=&quot;highlighter-rouge&quot;&gt;isRedColor&lt;/code&gt;方法筛选需要的苹果。下面介绍一个完整的演变过程。
如果从一堆苹果中找出大的苹果，你之前可能会写如下代码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Apple&amp;gt; findBigApples(List&amp;lt;Apple&amp;gt; apples) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (apple.getWeight() &amp;gt; 200) {
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;后来可能又有需求是需要找出红苹果，于是可能会新增一个找红苹果的方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;Apple&amp;gt; findRedApples(List&amp;lt;Apple&amp;gt; apples) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (apple.getColor() == Color.RED) {
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;findBigApples&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;findRedApples&lt;/code&gt;的唯一区别仅仅是判断苹果的条件，所以你可能会通过一个
接口，将筛选方法作为策略传入。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 判断策略
public interface Predicate&amp;lt;T&amp;gt; {
    boolean test(T t);
}

// 通过指定的策略查找苹果
public List&amp;lt;Apple&amp;gt; findApples(List&amp;lt;Apple&amp;gt; apples, Predicate&amp;lt;Apple&amp;gt; p) {
    List&amp;lt;Apple&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for (Apple apple : apples) {
        if (p.test(apple)) {  // 如果苹果满足p所代表的筛选方法
            results.add(apple);
        }
    }
    return results;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而如果使用了传递代码的能力，你可以将筛选大苹果的使用方法优化为如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, Apple::isBigEnough);

// 其中Apple::isBigEnough为Apple对象的方法引用，isBigEnough方法为判断是否是大苹果的方法
public boolean isBigEnough() {
    return this.getWeight() &amp;gt; 200;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而找出红苹果的方法可以优化为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, Apple::isRedColor);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而对于既要大苹果又要红苹果的情形，你可能会写一个仅用一次的方法，针对这种情况，可以通过
lambda表达式进行优化。&lt;/p&gt;
&lt;h3 id=&quot;使用lambda匿名函数&quot;&gt;使用lambda匿名函数&lt;/h3&gt;
&lt;p&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;public int add(int x, int y) {return x + y;}&lt;/code&gt;可等效于lambda匿名函数
&lt;code class=&quot;highlighter-rouge&quot;&gt;(int x, int y) -&amp;gt; {return x + y;}&lt;/code&gt;，当代码块只有一行时，可简写为&lt;code class=&quot;highlighter-rouge&quot;&gt;(x, y) -&amp;gt; x + y&lt;/code&gt;。
所以找出又大又红的苹果可以通过传入lambda表达式实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, (Apple apple) -&amp;gt; {
    return apple.isBigEnough() &amp;amp;&amp;amp; apple.isRedColor()
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果lambda仅有一行表达式，可以省略return语句和两端花括号，同时Apple参数类型也可以省略，
jvm会根据上下文分析正确的参数类型。所以简化版的表达式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, (apple) -&amp;gt; apple.isBigEnough() &amp;amp;&amp;amp; apple.isRedColor());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有高手会表示之前的java也能通过策略模式向方法中传递代码，比如通过匿名类对接口的实现来传递
不同的代码块。但是相比冗长地定义接口实现，通过直接传递方法引用和lambda表达式能更加
简化代码并且提供清晰的可读性。对比一下我们以前通过匿名类实现的找出大苹果的方式，体会一下
可读性。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findApples(apples, new Predicate&amp;lt;Apple&amp;gt; {
    @Override
    public boolean test(Apple apple) {
        return apple.isBigEnough();
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;引入lambda，并不只是一个语法糖，而是通过java7中新的&lt;a href=&quot;http://www.infoq.com/cn/articles/Invokedynamic-Javas-secret-weapon&quot;&gt;invokedynamic&lt;/a&gt;字节码，在运行时
确定执行的方法，这样可以将Groovy、Scala这类脚本语言进行粘合。&lt;/p&gt;

&lt;h2 id=&quot;流api&quot;&gt;流API&lt;/h2&gt;
&lt;p&gt;流提供了一种抽象的集合操作，通过类比SQL提供的数据操作指令，流提供了在java环境中的
一套编程模式，继续找苹果的例子，通过流，我们可以免去编写显示的循环操作，下面通流API，
使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;的筛选大苹果的方法，从所有苹果中筛选出大苹果并返回。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import static java.util.stream.Collections.toList;
List&amp;lt;Apple&amp;gt; bigApples = apples.stream()
                              .filter((apple) -&amp;gt; apple.isBigEnough())
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面的示例也可通过传递方法引用表示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Apple&amp;gt; bigApples = apples.stream()
                              .filter(Apple::isBigEnough)
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意其中并没有使用for循环，循环由流隐式内部实现了，由此带来的好处就是可以非常简单地
获得多处理机上的并行能力，在此之前java并不能主动利用多核，通过多线程提高效率。而使用
并行流，我们能轻松获得类似流水线的并行处理能力。而其他代码完全无需变更。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Apple&amp;gt; bigApples = apples.parallelStream()
                              .filter(Apple::isBigEnough)
                              .collect(toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;接口默认方法&quot;&gt;接口默认方法&lt;/h2&gt;
&lt;p&gt;接口通过&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;关键字可以支持接口中实现方法体，如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Sample {
    String getName();

    default void doSomething() {
        System.out.println(&quot;print default method.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过接口默认方法，当我们需要对接口进行变更时，可以避免让接口的所有实现类以及子类进行修改
和重新编译。接口实现类和其子类可以直接使用接口默认方法。&lt;/p&gt;

&lt;h2 id=&quot;了解更多&quot;&gt;了解更多&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26772632/&quot;&gt;《java8实战》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>grimkeke</name></author><summary type="html">为什么用java8 在了解和学习了java8之后，我发现java8带来的优势和所提升的效率，比学习它的成本要多得多， 所以在此向大家推荐使用java8的新特性： 通过方法参数传递代码块的能力以及使用lambda匿名函数替代实现匿名类。 新的流（Stream）API，提供了一种高层次集合操作方法，并带来了随手可得的并行能力。 为接口提供默认方法的能力，为扩展接口带来了福音。</summary></entry><entry><title type="html">How To Change Default JRE In IntelliJ Idea</title><link href="http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea.html" rel="alternate" type="text/html" title="How To Change Default JRE In IntelliJ Idea" /><published>2017-05-09T12:51:44+08:00</published><updated>2017-05-09T12:51:44+08:00</updated><id>http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea</id><content type="html" xml:base="http://0.0.0.0:4000/intellij/2017/05/09/how-to-change-default-jre-in-intellij-idea.html">&lt;p&gt;Intellij IDEA 默认情况下，使用的jdk的版本是1.6，当第一次启动IDEA的时候，如果系统中未安装jdk，则系统会自动到苹果官网下载jdk安装文件。如果你的系 统已经安装了jdk1.7或是更高的版本，同样首次打开IDEA的时候要求你安装苹果官网jdk1.6。&lt;/p&gt;

&lt;p&gt;为了免去多余的jdk安装，解决办法如下：&lt;/p&gt;

&lt;p&gt;到/Applications下找到IntelliJ IDEA 13，右键－&amp;gt;显示包内容－&amp;gt;Contents-&amp;gt;Info.plist，利用文本编辑器或是默认的xcode打开该文件，找到下列代码&lt;/p&gt;

&lt;key&gt;JVMVersion&lt;/key&gt;
&lt;string&gt;1.6*&lt;/string&gt;

&lt;p&gt;将&lt;string&gt;1.6*&lt;/string&gt;改为&lt;string&gt;1.7*&lt;/string&gt;保存。&lt;/p&gt;

&lt;p&gt;此时idea使用的jdk就是1.7及以上的版本了。&lt;/p&gt;</content><author><name>grimkeke</name></author><summary type="html">Intellij IDEA 默认情况下，使用的jdk的版本是1.6，当第一次启动IDEA的时候，如果系统中未安装jdk，则系统会自动到苹果官网下载jdk安装文件。如果你的系 统已经安装了jdk1.7或是更高的版本，同样首次打开IDEA的时候要求你安装苹果官网jdk1.6。</summary></entry><entry><title type="html">如何创建自己的github.io站点</title><link href="http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site.html" rel="alternate" type="text/html" title="如何创建自己的github.io站点" /><published>2017-03-26T16:59:44+08:00</published><updated>2017-03-26T16:59:44+08:00</updated><id>http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site</id><content type="html" xml:base="http://0.0.0.0:4000/hello/2017/03/26/how-to-build-your-own-github-io-site.html">&lt;p&gt;github提供了一种&lt;a href=&quot;https://pages.github.com/&quot;&gt;主页服务&lt;/a&gt;，当用户在github创建了一个(用户名.github.io)格式命名的项目后，
github会为其生成静态站点。 比如我的用户名为grimkeke，那么当我创建了grimkeke.github.io项目，并提交一个文本文件（如html）后，
访问&lt;a href=&quot;https://grimkeke.github.io&quot;&gt;https://grimkeke.github.io&lt;/a&gt;即可访问刚才提交的文件，需要注意项目名称必须为自身用户名，否则即使上传了文件，浏览器也会报错404.&lt;/p&gt;

&lt;p&gt;对于正式编写blog，推荐使用&lt;a href=&quot;https://jekyllrb.com/docs/quickstart/&quot;&gt;Jekyll&lt;/a&gt;，它支持markdown编写笔记，通过命令生成静态文件，并且与github完全打通，
通过jekyll创建的项目，直接上传至github后即为最终站点效果。&lt;/p&gt;

&lt;h4 id=&quot;如何使用jekyll&quot;&gt;如何使用jekyll&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Install Jekyll and Bundler gems through RubyGems
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll bundler&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create a new Jekyll site at ./myblog
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new myblog&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Change into your new directory
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd myblog&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build the site on the preview server
&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle exec jekyll serve&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now browse to http://localhost:4000&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>grimkeke</name></author><summary type="html">github提供了一种主页服务，当用户在github创建了一个(用户名.github.io)格式命名的项目后， github会为其生成静态站点。 比如我的用户名为grimkeke，那么当我创建了grimkeke.github.io项目，并提交一个文本文件（如html）后， 访问https://grimkeke.github.io即可访问刚才提交的文件，需要注意项目名称必须为自身用户名，否则即使上传了文件，浏览器也会报错404.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-03-26T13:59:44+08:00</published><updated>2017-03-26T13:59:44+08:00</updated><id>http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/jekyll/update/2017/03/26/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>grimkeke</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>